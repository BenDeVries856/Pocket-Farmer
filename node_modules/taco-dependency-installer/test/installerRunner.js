/**
 *******************************************************
 *                                                     *
 *   Copyright (C) Microsoft. All rights reserved.     *
 *                                                     *
 *******************************************************
 */
/// <reference path="../../typings/dependencyInstallerInterfaces.d.ts" />
/// <reference path="../../typings/lodash.d.ts"/>
/// <reference path="../../typings/mocha.d.ts"/>
/// <reference path="../../typings/mockery.d.ts"/>
/// <reference path="../../typings/mock-fs.d.ts"/>
/// <reference path="../../typings/rimraf.d.ts"/>
/// <reference path="../../typings/should.d.ts"/>
/// <reference path="../../typings/tacoTestsUtils.d.ts"/>
"use strict";
/* tslint:disable:no-var-requires */
// var require needed for should module to work correctly
// Note not import: We don't want to refer to shouldModule, but we need the require to occur since it modifies the prototype of Object.
var shouldModule = require("should");
/* tslint:enable:no-var-requires */
var FakeLogger = require("./fakeLogger");
var fs = require("fs");
var InstallerRunner = require("../installerRunner");
var _ = require("lodash");
var mockery = require("mockery");
var mockFs = require("mock-fs");
var os = require("os");
var path = require("path");
var tacoTestsUtils = require("taco-tests-utils");
var rimraf = require("rimraf");
var wrench = require("wrench");
var FakeTelemetryGenerator = tacoTestsUtils.TelemetryFakes.Generator;
var nodeFakes = tacoTestsUtils.NodeFakes;
describe("InstallerRunner", function () {
    // Important paths
    var runFolder = path.resolve(os.tmpdir(), "taco_dependency_installer_test_run");
    var tacoHome = path.join(runFolder, "taco_home");
    var installConfigFile = path.join(tacoHome, "installConfig.json");
    var testMetadataFile = path.resolve(__dirname, "test-data", "testMetadata.json");
    // Persistent installer runner instance
    var installerRunner;
    // Utility functions
    function createBuildConfig(dependencies) {
        if (fs.existsSync(installConfigFile)) {
            fs.unlinkSync(installConfigFile);
        }
        var jsonWrapper = {
            dependencies: dependencies
        };
        wrench.mkdirSyncRecursive(path.dirname(installConfigFile), 511); // 511 decimal is 0777 octal
        fs.writeFileSync(installConfigFile, JSON.stringify(jsonWrapper, null, 4));
    }
    before(function (done) {
        // Set ResourcesManager to test mode
        process.env["TACO_UNIT_TEST"] = true;
        // Set a temporary location for taco_home
        process.env["TACO_HOME"] = tacoHome;
        // Instantiate the persistent DependencyInstaller
        installerRunner = new InstallerRunner(installConfigFile, null, testMetadataFile);
        // Delete existing run folder if necessary
        rimraf(runFolder, function (err) {
            if (err) {
                done(err);
            }
            else {
                // Create the run folder for our tests
                wrench.mkdirSyncRecursive(runFolder, 511); // 511 decimal is 0777 octal
                done();
            }
        });
    });
    after(function (done) {
        // Restore ResourcesManager
        process.env["TACO_UNIT_TEST"] = false;
        // Clean up run folder
        rimraf(runFolder, done);
    });
    describe("parseInstallConfig()", function () {
        beforeEach(function () {
            if (fs.existsSync(installConfigFile)) {
                fs.unlinkSync(installConfigFile);
            }
        });
        it("should parse without errors a valid installConfig file", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "dependency5",
                    version: "1.0",
                    displayName: "test_value5",
                    installDestination: "test_value5"
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            var telemetry = new FakeTelemetryGenerator("");
            installerRunner.parseInstallConfig(telemetry);
            telemetry.getEventsProperties().should.eql([]);
        });
        it("should report the correct error when installConfig does not exist", function () {
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("InstallConfigNotFound");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        it("should report the correct error when installConfig is malformed", function () {
            wrench.mkdirSyncRecursive(path.dirname(installConfigFile), 511); // 511 decimal is 0777 octal
            // Case where the file does not contain a valid JSON object
            fs.writeFileSync(installConfigFile, "{\"dependencies\":");
            var telemetry = new FakeTelemetryGenerator("");
            try {
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("InstallConfigMalformed");
                telemetry.getEventsProperties().should.eql([]);
            }
            // Case where the file does not have a dependencies node
            fs.writeFileSync(installConfigFile, "{\"unknownObject\":\"unknownValue\"}");
            telemetry = new FakeTelemetryGenerator("");
            try {
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("InstallConfigMalformed");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        it("should report the correct error when installConfig contains an unknown ID", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "unknownDependency",
                    version: "1.0",
                    displayName: "test_value5",
                    installDestination: "test_value5"
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("UnknownDependency");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        it("should report the correct error when installConfig contains an unknown version ID", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "dependency5",
                    version: "unknown",
                    displayName: "test_value5",
                    installDestination: "test_value5"
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("UnknownVersion");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        (os.platform() === "win32" ? it : it.skip)("should report the correct error when installConfig contains an invalid install path", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "dependency5",
                    version: "1.0",
                    displayName: "test_value5",
                    installDestination: "\\\\//::::****>>><<<<\"\"my\\folder"
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("InvalidInstallPath");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        it("should report the correct error when installConfig contains a non-empty install path", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "dependency5",
                    version: "1.0",
                    displayName: "test_value5",
                    installDestination: runFolder
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("PathNotEmpty");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
        it("should report the correct error when installConfig contains duplicate install paths", function () {
            var missingDependencies = [
                {
                    id: "dependency1",
                    version: "1.0",
                    displayName: "test_value1",
                    installDestination: "test_value1"
                },
                {
                    id: "dependency5",
                    version: "1.0",
                    displayName: "test_value5",
                    installDestination: "test_value7"
                },
                {
                    id: "dependency7",
                    version: "1.0",
                    displayName: "test_value7",
                    installDestination: "test_value7",
                    licenseUrl: "test_value7"
                }
            ];
            createBuildConfig(missingDependencies);
            try {
                var telemetry = new FakeTelemetryGenerator("");
                installerRunner.parseInstallConfig(telemetry);
            }
            catch (err) {
                err.message.should.be.exactly("PathNotUnique");
                telemetry.getEventsProperties().should.eql([]);
            }
        });
    });
    describe("instantiateInstaller()", function () {
        it("should instantiate a sub-installer without error", function () {
            var dependency = {
                id: "dependency1",
                version: "1.0",
                displayName: "test_value1",
                installDestination: "test_value1"
            };
            installerRunner.instantiateInstaller(dependency);
        });
    });
    describe("telemetry", function () {
        // Mocks used by the tests
        var mockPath;
        var fakeTelemetryHelper;
        var fakeProcess;
        var androidSdkInstallerClass;
        var childProcessModule;
        var installerRunnerUsingMocks;
        var files = {};
        // Default values for configuration files
        var validMetadata;
        var validInstallConfig;
        before(function () {
            // We tell mockery to replace "require()" with our own custom mock objects
            mockery.enable({ useCleanCache: true, warnOnUnregistered: false });
            fakeProcess = new nodeFakes.Process().fakeDeterministicHrtime();
            var fakeProcessUtilsModule = { ProcessUtils: fakeProcess.buildProcessUtils() };
            mockery.registerMock("./processUtils", fakeProcessUtilsModule); // TelemetryHelper loads ./processUtils
            var tacoUtils = require("taco-utils");
            tacoUtils.Telemetry.init("TACO/dependencyInstaller", "1.2.3", { isOptedIn: false });
            // Register mocks. child_process and taco-utils mocks needs to be registered before 
            // AndroidSdkInstaller is required for the mocking to work
            childProcessModule = new nodeFakes.ChildProcessModule().fakeAllExecCallsEndingWithErrors();
            mockery.registerMock("child_process", childProcessModule);
            // Reload taco-tests-utils but now with the fake processUtils loaded, so the fake telemetry will use the fake process
            var tacoTestsUtilsWithMocks = require("taco-tests-utils");
            fakeTelemetryHelper = new tacoTestsUtilsWithMocks.TelemetryFakes.Helper();
            var tacoUtilsWithFakes = _.extend({}, tacoUtils, { TelemetryHelper: fakeTelemetryHelper, HasFakes: true }, fakeProcessUtilsModule);
            mockery.registerMock("taco-utils", tacoUtilsWithFakes); // AndroidSdkInstaller loads taco-utils
            // We need to mock path if we want to run windows tests on a mac, so it'll use ; as path delimiter
            mockPath = _.extend({}, path);
            mockery.registerMock("path", mockPath); // installerUtils uses path.delimiter, and it breaks the Windows tests on mac if not
            // We require the AndroidSdkInstaller file, which will use all the mocked dependencies
            installerRunnerUsingMocks = require("../installerRunner");
            var dependencies = [{
                    id: "AndroidSdk", version: "1.2.3", displayName: "Android SDK",
                    installDestination: "C:\\installdir\\"
                }];
            validInstallConfig = { dependencies: dependencies };
            var adroidSdkInstallerPath = "scriptToInstallAndroid.js";
            var metadataDependencies = {
                AndroidSdk: {
                    versions: { "1.2.3": {} },
                    installerPath: adroidSdkInstallerPath
                }
            };
            var baseDirName = path.dirname(__dirname);
            var fullInstallerPath = path.join(baseDirName, adroidSdkInstallerPath);
            var resourcesPath = path.join(baseDirName, "resources", "en", "resources.json");
            validMetadata = { dependencies: metadataDependencies };
            files[fullInstallerPath] = "";
            files[resourcesPath] = JSON.stringify({ InstallConfigMalformed: "InstallConfigMalformed" }); // We use this string resource
            mockery.registerMock(fullInstallerPath, function () { return { run: function () { } }; });
        });
        after(function () {
            // Clean up and revert everything back to normal
            mockery.deregisterAll();
            mockery.disable();
            mockFs.restore();
        });
        beforeEach(function () {
            fakeTelemetryHelper.clear(); // So we'll only get the new events in each scenario
        });
        function registerMockedConfigurationFiles(installConfig, metadata) {
            files[installConfigFile] = JSON.stringify(installConfig);
            files[testMetadataFile] = JSON.stringify(metadata);
            mockery.registerMock(installConfigFile, installConfig);
            mockery.registerMock(testMetadataFile, metadata);
            mockFs(files);
        }
        function telemetryGeneratedShouldBe(expectedTelemetry, done) {
            var installerRunnerInstance = new installerRunnerUsingMocks(installConfigFile, new FakeLogger(), testMetadataFile);
            installerRunnerInstance.run()
                .then(function () {
                return fakeTelemetryHelper.getAllSentEvents().then(function (allSentEvents) {
                    allSentEvents.should.eql(expectedTelemetry);
                    return null;
                });
            }).done(function () { return done(); }, done);
        }
        it("should generate installDestination null telemetry when a value is null", function (done) {
            registerMockedConfigurationFiles(validInstallConfig, validMetadata);
            var expectedTelemetry = [
                {
                    "initialStep.time": { isPii: false, value: "2000" },
                    step: { isPii: false, value: "initialStep" }
                },
                {
                    "installDestination.defaultIsNull": { isPii: false, value: "true" },
                    "installDestination.destinationIsNull": { isPii: false, value: "false" },
                    "parseInstallConfig.time": { isPii: false, value: "1000" },
                    step: { isPii: false, value: "parseInstallConfig" }
                },
                {
                    "runInstallers.time": { isPii: false, value: "1000" },
                    step: { isPii: false, value: "runInstallers" }
                },
                {
                    installerErrorFlag: { isPii: false, value: "false" },
                    lastStepExecuted: { isPii: false, value: "runInstallersFinished" },
                    "runInstallersFinished.time": { isPii: false, value: "2000" },
                    step: { isPii: false, value: "runInstallersFinished" },
                    time: { isPii: false, value: "7000" }
                }
            ];
            return telemetryGeneratedShouldBe(expectedTelemetry, done);
        });
        it("should generate catch error telemetry when a configuration file is invalid", function (done) {
            registerMockedConfigurationFiles({}, validMetadata); // We send invalid objects on purpose
            var expectedTelemetry = [
                {
                    "initialStep.time": { isPii: false, value: "2000" },
                    step: { isPii: false, value: "initialStep" }
                },
                {
                    "parseInstallConfig.time": { isPii: false, value: "1000" },
                    step: { isPii: false, value: "parseInstallConfig" }
                },
                {
                    "catch.time": { isPii: false, value: "2000" },
                    errorMessage: { isPii: false, value: "InstallConfigMalformed" },
                    lastStepExecuted: { isPii: false, value: "catch" },
                    step: { isPii: false, value: "catch" },
                    time: { isPii: false, value: "5000" }
                }
            ];
            return telemetryGeneratedShouldBe(expectedTelemetry, done);
        });
    });
});

//# sourceMappingURL=installerRunner.js.map
