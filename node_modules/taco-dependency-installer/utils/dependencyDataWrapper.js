/**
 *******************************************************
 *                                                     *
 *   Copyright (C) Microsoft. All rights reserved.     *
 *                                                     *
 *******************************************************
 */
/// <reference path="../../typings/dependencyInstallerInterfaces.d.ts" />
"use strict";
var fs = require("fs");
var os = require("os");
var path = require("path");
var DependencyDataWrapper = (function () {
    function DependencyDataWrapper(dependenciesMetadataFilePath) {
        var loadPath = dependenciesMetadataFilePath || DependencyDataWrapper.defaultDependenciesMetadataFilePath;
        var metadata = JSON.parse(fs.readFileSync(loadPath, "utf8"));
        this.dependencies = metadata.dependencies;
        this.unsupported = metadata.unsupported;
    }
    /*
     * Returns the installation destination for the specified dependency ID, version ID and platform ID (or the current system platform if no platform is specified).
     * Will return null if the info is missing from our metadata or if either the dependency ID, the version ID or the platform ID does not exist.
     */
    DependencyDataWrapper.prototype.getInstallDirectory = function (id, version, platform, architecture) {
        if (platform === void 0) { platform = process.platform; }
        if (architecture === void 0) { architecture = os.arch(); }
        if (this.isSystemSupported(id, version, platform, architecture)) {
            return this.dependencies[id].versions[version][platform][architecture].installDestination;
        }
        return null;
    };
    /*
     * Returns the display name for the specified dependency. Will return null if the info is missing in our metadata or if the dependency does not exist.
     */
    DependencyDataWrapper.prototype.getDisplayName = function (id) {
        if (this.dependencyExists(id)) {
            return this.dependencies[id].displayName;
        }
        return null;
    };
    /*
     * Returns the path to the specialized installer class of the specified dependency, or null if the dependency doesn't exist.
     */
    DependencyDataWrapper.prototype.getInstallerPath = function (id) {
        if (this.dependencyExists(id)) {
            return this.dependencies[id].installerPath;
        }
        return null;
    };
    /*
     * Returns the license url for the specified dependency. Will return null if the info is missing in our metadata or if the dependency does not exist.
     */
    DependencyDataWrapper.prototype.getLicenseUrl = function (id) {
        if (this.dependencyExists(id)) {
            return this.dependencies[id].licenseUrl;
        }
        return null;
    };
    /*
     * Returns the list of prerequisites for the specified dependency. Will return null if the info is missing in our metadata or if the dependency does not exist.
     */
    DependencyDataWrapper.prototype.getPrerequisites = function (id) {
        if (this.dependencyExists(id)) {
            return this.dependencies[id].prerequisites;
        }
        return null;
    };
    /*
     * Returns the installer info for the specified dependency. Will return null if either the dependency ID, the version ID or the platform (or the current system
     * platform if no platform is specified) ID does not exist.
     */
    DependencyDataWrapper.prototype.getInstallerInfo = function (id, version, platform, architecture) {
        if (platform === void 0) { platform = process.platform; }
        if (architecture === void 0) { architecture = os.arch(); }
        if (this.isSystemSupported(id, version, platform, architecture)) {
            var infoSource = this.dependencies[id].versions[version][platform][architecture];
            return JSON.parse(JSON.stringify(infoSource)); // Using JSON.parse and JSON.stringify to clone the object
        }
        return null;
    };
    /*
     * Returns the installer steps for the specified dependency. Will return null if either the dependency ID, the version ID or the platform (or the current system
     * platform if no platform is specified) ID does not exist.
     */
    DependencyDataWrapper.prototype.getInstallerSteps = function (id, version, platform, architecture) {
        if (platform === void 0) { platform = process.platform; }
        if (architecture === void 0) { architecture = os.arch(); }
        if (this.isSystemSupported(id, version, platform, architecture)) {
            return this.dependencies[id].versions[version][platform][architecture].steps;
        }
        return null;
    };
    /*
     * Looks into the specified dependency node and returns the first version ID that contains a node for either the specified platform (or the current system
     * platform if no platform is specified) or the "default" platform. Returns null if no such version ID exists.
     */
    DependencyDataWrapper.prototype.getFirstValidVersion = function (id, platform, architecture) {
        if (platform === void 0) { platform = process.platform; }
        if (architecture === void 0) { architecture = os.arch(); }
        var self = this;
        var validVersion;
        if (this.dependencyExists(id) && !!this.dependencies[id].versions) {
            Object.keys(this.dependencies[id].versions).some(function (version) {
                if (self.isSystemSupported(id, version, platform, architecture)) {
                    validVersion = version;
                    return true;
                }
                return false;
            });
        }
        return validVersion;
    };
    /*
     * Returns the link for the help of the specified known unsupported dependency, or null if the dependency is not a known unsupported or if it doesn't have any help link.
     */
    DependencyDataWrapper.prototype.getInstallHelp = function (id) {
        if (this.isKnownUnsupported(id)) {
            return this.unsupported[id].installHelp;
        }
        return null;
    };
    /*
     * Returns true if the specified dependency exists, false otherwise.
     */
    DependencyDataWrapper.prototype.dependencyExists = function (id) {
        return !!this.dependencies[id];
    };
    /*
     * Returns true if the specified dependency has a node for the specified version, false otherwise.
     */
    DependencyDataWrapper.prototype.versionExists = function (id, version) {
        return this.dependencyExists(id) &&
            !!this.dependencies[id].versions &&
            !!this.dependencies[id].versions[version];
    };
    /*
     * Returns true if the specified dependency has a node for the specified version and that version has a node for either the specified platform (or the current
     * system platform if no platform is specified), or the "default" platform. Returns false otherwise.
     */
    DependencyDataWrapper.prototype.isSystemSupported = function (id, version, platform, architecture) {
        if (platform === void 0) { platform = process.platform; }
        if (architecture === void 0) { architecture = os.arch(); }
        return this.versionExists(id, version) &&
            !!this.dependencies[id].versions[version][platform] &&
            !!this.dependencies[id].versions[version][platform][architecture];
    };
    /*
     * Returns true if the specified dependency is implicit, false if it isn't or if the specified ID does not exist. A dependency is implicit if it is installed as part of a different dependency. For
     * example, Android packages (android-21, android-platform-tools, etc) are installed directly as part of installing Android SDK in this dependency installer, so we don't want to do extra processing
     * to handle these packages specifically. Thus, they are marked as implicit dependencies.
     */
    DependencyDataWrapper.prototype.isImplicit = function (id) {
        return this.dependencyExists(id) && !!this.dependencies[id].isImplicit;
    };
    /*
     * Returns true if the specified dependency is known to be unsupported, false otherwise.
     */
    DependencyDataWrapper.prototype.isKnownUnsupported = function (id) {
        return !!this.unsupported[id];
    };
    DependencyDataWrapper.defaultDependenciesMetadataFilePath = path.resolve(__dirname, "..", "platformDependencies.json");
    return DependencyDataWrapper;
})();
module.exports = DependencyDataWrapper;

//# sourceMappingURL=dependencyDataWrapper.js.map
