/**
 *******************************************************
 *                                                     *
 *   Copyright (C) Microsoft. All rights reserved.     *
 *                                                     *
 *******************************************************
 */
/// <reference path="../../typings/hashFiles.d.ts" />
/// <reference path="../../typings/request.d.ts" />
/// <reference path="../../typings/wrench.d.ts" />
"use strict";
var childProcess = require("child_process");
var fs = require("fs");
var hashFiles = require("hash-files");
var os = require("os");
var path = require("path");
var Q = require("q");
var readline = require("readline");
var request = require("request");
var wrench = require("wrench");
var InstallerProtocol = require("../elevatedInstallerProtocol");
var tacoUtils = require("taco-utils");
var resources = require("../resources/resourceManager");
var installerDataType = InstallerProtocol.DataType;
var TacoGlobalConfig = tacoUtils.TacoGlobalConfig;
var utils = tacoUtils.UtilHelper;
var InstallerUtils = (function () {
    function InstallerUtils() {
    }
    /**
     * Verifies if the specified file is valid by comparing its sha1 signature and its size in bytes with the provided expectedSha1 and expectedBytes.
     *
     * @param {string} filePath Path to the file to verify
     * @param {InstallerUtils.IFileSignature} fileSignature Signature of the file, may include byte size and SHA1 checksum
     *
     * @return {boolean} A boolean indicating whether the file has the expected signature or not
     */
    InstallerUtils.isFileClean = function (filePath, fileSignature) {
        var isClean = true;
        if (fileSignature) {
            if (fileSignature.sha1 && fileSignature.sha1 !== InstallerUtils.calculateFileSha1(filePath)) {
                isClean = false;
            }
            if (fileSignature.bytes && fileSignature.bytes !== InstallerUtils.getFileBytes(filePath)) {
                isClean = false;
            }
        }
        return isClean;
    };
    /**
     * Uses the request.Options object provided to download a file from a url and save it to filepath. Verifies that the downloaded file is valid using expectedSha1 and expectedBytes.
     * If the download fails, it will try again up to a maximum of maxDownloadAttempts (defaults to 1).
     *
     * @param {request.Options} options The request package options to put in the request
     * @param {string} filePath The path to which save the downloaded file
     * @param {InstallerUtils.IFileSignature} fileSignature The expected file signature (byte size and SHA1 checksum) of the downloaded file
     * @param {number} maxDownloadAttempts = 1 The maximum number of tries before returning an error
     *
     * @return {Q.Promise<any>} A promise resolved with an empty object if the download succeeds, or rejected with the appropriate error otherwise
     */
    InstallerUtils.downloadFile = function (requestOptions, filePath, fileSignature, maxDownloadAttempts) {
        if (maxDownloadAttempts === void 0) { maxDownloadAttempts = 1; }
        // If the file already exists, verify that it is not corrupt
        if (fs.existsSync(filePath)) {
            if (InstallerUtils.isFileClean(filePath, fileSignature)) {
                // We already have a clean file, use this one rather than downloading a new one
                return Q.resolve({});
            }
            // The existing file is not the expected one; delete it
            fs.unlinkSync(filePath);
        }
        else {
            // Create the directory tree for the downloaded file
            wrench.mkdirSyncRecursive(path.dirname(filePath), 511); // 511 decimal is 0777 octal
        }
        // Build the promise chain for multiple attempts at downloading
        var promise = Q.reject();
        for (var i = 0; i < maxDownloadAttempts; i++) {
            promise = promise
                .then(function () {
                // If the download succeeded, do nothing
            }, function () {
                // If the download fails, try again.
                // Note: there may be some specific error cases where we know retrying to download won't fix the issue. If we ever come across such a case, detect it here and don't retry.
                return InstallerUtils.downloadFileInternal(requestOptions, filePath, fileSignature);
            });
        }
        return promise;
    };
    /**
     * Prompts the user with the specified message and returns a promise resolved with what the user typed.
     *
     * @param {string} message The message that should be used to question the user for the prompt
     *
     * @return {Q.Promise<string>} A promise resolved with the user's response
     */
    InstallerUtils.promptUser = function (message) {
        var deferred = Q.defer();
        var rl = readline.createInterface({
            input: tacoUtils.ProcessUtils.getProcess().stdin,
            output: tacoUtils.ProcessUtils.getProcess().stdout
        });
        rl.question(message, function (answer) {
            rl.close();
            deferred.resolve(answer);
        });
        return deferred.promise;
    };
    /**
     * Determines whether the specified environment variable needs to be set or not. If the variable doesn't exist, the result is true. If the variable already exists but is set to the desired value, the
     * result is false. If it exists but is different than what is desired, the user will be prompted for overwrite, and the result will depend on the user's answer. The result is wrapped in a promise.
     *
     * @param {string} name The name of the environment variable to set
     * @param {string} value The desired value for the specified environment variable
     * @param {InstallerProtocol.ILogger} logger The logger for the current process
     *
     * @return {Q.Promise<boolean>} A promise resolved with a boolean indicating whether the specified environment variable must be set
     */
    InstallerUtils.mustSetSystemVariable = function (name, value, logger) {
        if (!tacoUtils.ProcessUtils.getProcess().env[name]) {
            return Q.resolve(true);
        }
        else if (path.resolve(utils.expandEnvironmentVariables(tacoUtils.ProcessUtils.getProcess().env[name])) === path.resolve(utils.expandEnvironmentVariables(value))) {
            // If this environment variable is already defined, but it is already set to what we need, we don't need to set it again
            return Q.resolve(false);
        }
        return logger.promptForEnvVariableOverwrite(name)
            .then(function (answer) {
            if (answer === resources.getString("YesString")) {
                logger.log(resources.getString("OverwritingVariable", name));
                return Q.resolve(true);
            }
            else {
                logger.log(resources.getString("SkipOverwriteWarning", name, value));
                return Q.resolve(false);
            }
        });
    };
    /**
     * Prompts the user for permission to overwrite the specified system environment variable. Uses the specified socket for communication.
     *
     * @param {string} name The name of the environment variable to set
     * @param {NodeJSNet.Socket} socket The socket over which to send the prompt request
     *
     * @return {Q.Promise<string>} A promise resolved with a string containing the user's response to the prompt
     */
    InstallerUtils.promptForEnvVariableOverwrite = function (name, socket) {
        // If we auto-accept prompts, return with the YesString
        if (TacoGlobalConfig.noPrompt) {
            return Q.resolve(resources.getString("YesString"));
        }
        // Otherwise, we prompt the user
        var deferred = Q.defer();
        var dataListener = function (data) {
            var stringData = data.toString();
            socket.removeListener("data", dataListener);
            deferred.resolve(stringData);
        };
        InstallerUtils.sendData(socket, resources.getString("SystemVariableExists", name));
        socket.on("data", dataListener);
        InstallerUtils.sendData(socket, resources.getString("YesExampleString"), installerDataType.Prompt);
        return deferred.promise;
    };
    /**
     * Searches the provided Path environment variable value for the specified value
     *
     * @param {string} valueToCheck The value to check for in the Path environment variable
     * @param {string} pathValue The current value of the Path variable
     *
     * @return {boolean} A boolean set to true if the Path system variable already contains the specified value in one of its segments
     */
    InstallerUtils.pathContains = function (valueToCheck, pathValue) {
        if (pathValue === void 0) { pathValue = tacoUtils.ProcessUtils.getProcess().env[InstallerUtils.PATH_NAME]; }
        if (!pathValue) {
            return false;
        }
        return pathValue.split(path.delimiter).some(function (segment) {
            return path.resolve(utils.expandEnvironmentVariables(segment)) === path.resolve(utils.expandEnvironmentVariables(valueToCheck));
        });
    };
    /**
     * Sends data over the provided socket using the InstallerProtocol format
     *
     * @param {NodeJSNet.Socket} socketHandle The socket to use for the communication
     * @param {string} message The message to send over the socket
     * @param {InstallerProtocol.DataType} dataType = InstallerProtocol.DataType.Log The type of data to send over the socket
     */
    InstallerUtils.sendData = function (socketHandle, message, dataType) {
        if (dataType === void 0) { dataType = installerDataType.Log; }
        var data = {
            dataType: dataType,
            message: message
        };
        socketHandle.write(JSON.stringify(data) + os.EOL);
    };
    /**
     * Globally tnstalls the given package from npm
     *
     * @param {stringt} npmPackage The name of the npm package
     *
     * @return {Q.Promise} An empty promise if the operation succeeds
     */
    InstallerUtils.installNpmPackage = function (npmPackage) {
        var deferred = Q.defer();
        var command = "npm install -g " + npmPackage;
        childProcess.exec(command, function (error, stdout, stderr) {
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve({});
            }
        });
        return deferred.promise;
    };
    InstallerUtils.calculateFileSha1 = function (filePath) {
        var options = {
            files: [filePath],
            noGlob: true,
            algorithm: "sha1"
        };
        return hashFiles.sync(options);
    };
    InstallerUtils.getFileBytes = function (filePath) {
        return fs.statSync(filePath).size;
    };
    InstallerUtils.downloadFileInternal = function (requestOptions, filePath, expectedProperties) {
        var deferred = Q.defer();
        request(requestOptions)
            .on("error", function (err) {
            deferred.reject(err);
        })
            .on("response", function (response) {
            if (response.statusCode < 200 || response.statusCode >= 300) {
                // Even though 1xx and 3xx codes aren't error codes, it still means that the specified URL does not point to a downloadable file, so error out
                deferred.reject(new Error(resources.getString("FileNotFound")));
            }
            var fws = fs.createWriteStream(filePath);
            response.pipe(fws);
            fws.on("finish", function () {
                // Verify if the file is clean
                if (InstallerUtils.isFileClean(filePath, expectedProperties)) {
                    deferred.resolve({});
                }
                else {
                    deferred.reject(new Error(resources.getString("FileCorruptError")));
                }
            });
            fws.on("error", function (err) {
                deferred.reject(err);
            });
        });
        return deferred.promise;
    };
    InstallerUtils.PATH_NAME = "PATH"; // *nix uses uppercase and it's case sensitive. Windows is case insensitive
    return InstallerUtils;
})();
module.exports = InstallerUtils;

//# sourceMappingURL=installerUtils.js.map
