/**
  *******************************************************
  *                                                     *
  *   Copyright (C) Microsoft. All rights reserved.     *
  *                                                     *
  *******************************************************
  */
/// <reference path="../../typings/dependencyInstallerInterfaces.d.ts" />
/// <reference path="../../typings/Q.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var childProcess = require("child_process");
var fs = require("fs");
var os = require("os");
var path = require("path");
var Q = require("q");
var util = require("util");
var InstallerBase = require("./installerBase");
var resources = require("../resources/resourceManager");
var tacoUtils = require("taco-utils");
var utilHelper = tacoUtils.UtilHelper;
var AndroidPackagesInstaller = (function (_super) {
    __extends(AndroidPackagesInstaller, _super);
    function AndroidPackagesInstaller(installerInfo, softwareVersion, installTo, logger, steps) {
        _super.call(this, installerInfo, softwareVersion, installTo, logger, steps, "androidPackages");
    }
    AndroidPackagesInstaller.removeOptionsFromStderr = function (stderr) {
        // For some reason, Android SDK outputs the java options specified in _JAVA_OPTIONS env variable to stderr when it picks them up. This means TACO detects an error in the SDK command,
        // when in reality everything went fine. Here, we filter out such lines from the error output.
        return stderr.split(os.EOL).filter(function (line) {
            // Return true to keep a line; we keep it if it doesn't start with "Picked up "
            return line.indexOf("Picked up ") === -1;
        }).join(os.EOL);
    };
    AndroidPackagesInstaller.prototype.installWin32 = function () {
        return this.installDefault();
    };
    AndroidPackagesInstaller.prototype.installDarwin = function () {
        return this.installDefault();
    };
    AndroidPackagesInstaller.prototype.buildAndroidCommands = function () {
        // Read the ANDROID_HOME from the process
        var androidHomeValue = process.env[AndroidPackagesInstaller.ANDROID_HOME_NAME];
        if (androidHomeValue) {
            // ANDROID_HOME is set, use that to find the android executable
            androidHomeValue = utilHelper.expandEnvironmentVariables(androidHomeValue);
            // Build the android and adb commands and save them in members for reusability
            var androidExecutable = os.platform() === "win32" ? "android.bat" : "android";
            var adbExecutable = os.platform() === "win32" ? "adb.exe" : "adb";
            this.androidCommand = path.join(androidHomeValue, "tools", androidExecutable);
            this.adbCommand = path.join(androidHomeValue, "platform-tools", adbExecutable);
        }
        else {
            // ANDROID_HOME is not set, but the android and adb executables might still be in the PATH
            this.androidCommand = "android";
            this.adbCommand = "adb";
        }
    };
    AndroidPackagesInstaller.prototype.executeAndroidCommand = function (args, nameForTelemetry, shouldAutomaticallyAcceptLicenseTerms) {
        var _this = this;
        var deferred = Q.defer();
        var stdErrOutput = "";
        var stdOutput = "";
        var cp = os.platform() === "darwin" ?
            childProcess.spawn(this.androidCommand, args, { uid: parseInt(process.env.SUDO_UID, 10), gid: parseInt(process.env.SUDO_GID, 10) }) : childProcess.spawn(this.androidCommand, args);
        cp.stdout.on("data", function (data) {
            stdOutput += data.toString();
        });
        cp.stderr.on("data", function (data) {
            stdErrOutput += data.toString();
        });
        cp.on("error", function (err) {
            _this.telemetry
                .add("error.description", "ErrorOnChildProcess on " + nameForTelemetry, /*isPii*/ false)
                .addError(err);
            if (err.code === "ENOENT") {
                deferred.reject(new Error(resources.getString("AndroidCommandNotFound", path.basename(_this.androidCommand))));
            }
            else {
                deferred.reject(err);
            }
        });
        cp.on("exit", function (code) {
            stdErrOutput = AndroidPackagesInstaller.removeOptionsFromStderr(stdErrOutput);
            if (stdErrOutput || code) {
                _this.telemetry
                    .add("error.description", "ErrorOnExitOfChildProcess on " + nameForTelemetry, /*isPii*/ false)
                    .add("error.code", code, /*isPii*/ false)
                    .add("error.message", stdErrOutput, /*isPii*/ true);
                var errorString = stdErrOutput || resources.getString("InstallerExitCode", util.format("%s %s", _this.androidCommand, args.join(" ")), code);
                deferred.reject(new Error(errorString));
            }
            else {
                deferred.resolve(stdOutput);
            }
        });
        if (shouldAutomaticallyAcceptLicenseTerms) {
            cp.stdout.on("data", function (data) {
                var stringData = data.toString();
                if (/\[y\/n\]:/.test(stringData)) {
                    // Accept license terms
                    cp.stdin.write("y" + os.EOL);
                    cp.stdin.end();
                }
            });
        }
        return deferred.promise;
    };
    AndroidPackagesInstaller.prototype.getAvailableAndroidPackages = function () {
        var _this = this;
        // Call "android list sdk -e"
        var args = [
            "list",
            "sdk",
            "-e"
        ];
        var outputPromise = this.executeAndroidCommand(args, "getAvailableAndroidPackages", 
        /*shouldAutomaticallyAcceptLicenseTerms*/ false);
        return outputPromise.then(function (output) {
            _this.availablePackages = [];
            // Parse for package ids and save them
            var regex = /id: \d+ or "(.+)"/g;
            var match = regex.exec(output);
            while (match) {
                _this.availablePackages.push(match[1]); // Index 0 is the entire matched line, index 1 is the captured group which is the actual package ID
                match = regex.exec(output);
            }
        });
    };
    AndroidPackagesInstaller.prototype.getPlatformToolsPackageId = function () {
        // Look in the list of available packages for the platform-tools package
        var packageIdIndex = this.availablePackages.indexOf(AndroidPackagesInstaller.PLATFORM_TOOLS_PKG);
        // If none is found, it means the latest platform tools are already installed, so just return an empty string; otherwise return the full ID
        return packageIdIndex === -1 ? "" : this.availablePackages[packageIdIndex];
    };
    AndroidPackagesInstaller.prototype.getBuildToolsPackageId = function () {
        // Look in the list of available packages for one that starts with the build-tools prefix
        var packageId = "";
        this.availablePackages.some(function (pkg) {
            if (pkg.indexOf(AndroidPackagesInstaller.BUILD_TOOLS_PKG_PREFIX) === 0) {
                packageId = pkg;
                return true;
            }
            return false;
        });
        // If none is found, it means the latest build tools are already installed, so just return an empty string; otherwise return the full ID
        return packageId;
    };
    AndroidPackagesInstaller.prototype.getAndroidTargetPackageId = function () {
        // Read the Android project properties
        var projectPropertiesPath = path.join("platforms", "android", "project.properties");
        var fileContent = fs.readFileSync(projectPropertiesPath).toString();
        // Find the value at the "target=" line
        var androidTargetId = /target=(.+)/.exec(fileContent)[1];
        // Make sure the android target is in the list of available packages, otherwise it is an error state
        if (this.availablePackages.indexOf(androidTargetId) === -1) {
            throw new Error(resources.getString("UnknownAndroidTarget", androidTargetId, projectPropertiesPath));
        }
        return androidTargetId;
    };
    AndroidPackagesInstaller.prototype.installDefault = function () {
        var self = this;
        this.buildAndroidCommands();
        return Q({})
            .then(function () {
            // Read available packages and save them in a member
            return self.getAvailableAndroidPackages();
        })
            .then(function () {
            var packagesToInstall = [];
            // Get the build-tools package to install
            var platformToolsPackage = self.getPlatformToolsPackageId();
            if (platformToolsPackage) {
                packagesToInstall.push(platformToolsPackage);
            }
            // Get the build-tools package to install
            var buildToolsPackage = self.getBuildToolsPackageId();
            if (buildToolsPackage) {
                packagesToInstall.push(buildToolsPackage);
            }
            // Get the android target package to install
            try {
                var androidTargetPackage = self.getAndroidTargetPackageId();
                if (androidTargetPackage) {
                    packagesToInstall.push(androidTargetPackage);
                }
            }
            catch (err) {
                // An error will occur if the Android target is unknown
                return Q.reject(err);
            }
            // Build the list of packages to install
            var packagesFilter = packagesToInstall.join(",");
            // Invoke the update command
            return self.installAndroidPackages(packagesFilter)
                .then(function () {
                // Kill the adb server
                return self.killAdb();
            });
        });
    };
    AndroidPackagesInstaller.prototype.installAndroidPackages = function (packagesFilter) {
        // Install Android packages
        var args = [
            "update",
            "sdk",
            "-u",
            "--filter",
            packagesFilter
        ];
        return this.executeAndroidCommand(args, "installAndroidPackages", 
        /*shouldAutomaticallyAcceptLicenseTerms*/ true);
    };
    AndroidPackagesInstaller.prototype.killAdb = function () {
        var _this = this;
        // Kill stray adb processes - this is an important step
        // as stray adb processes spawned by the android installer
        // can result in a hang post installation
        var deferred = Q.defer();
        var adbProcess = childProcess.spawn(this.adbCommand, ["kill-server"]);
        adbProcess.on("error", function (err) {
            _this.telemetry
                .add("error.description", "ErrorOnKillingAdb in killAdb", /*isPii*/ false)
                .addError(err);
            if (err.code === "ENOENT") {
                deferred.reject(new Error(resources.getString("AndroidCommandNotFound", "adb")));
            }
            else {
                deferred.reject(err);
            }
        });
        adbProcess.on("exit", function (code) {
            deferred.resolve({});
        });
        return deferred.promise;
    };
    AndroidPackagesInstaller.ANDROID_HOME_NAME = "ANDROID_HOME";
    AndroidPackagesInstaller.PLATFORM_TOOLS_PKG = "platform-tools";
    AndroidPackagesInstaller.BUILD_TOOLS_PKG_PREFIX = "build-tools-";
    return AndroidPackagesInstaller;
})(InstallerBase);
module.exports = AndroidPackagesInstaller;

//# sourceMappingURL=androidPackagesInstaller.js.map
