/**
 *******************************************************
 *                                                     *
 *   Copyright (C) Microsoft. All rights reserved.     *
 *                                                     *
 *******************************************************
 */
/// <reference path="../typings/dependencyInstallerInterfaces.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/tacoUtils.d.ts" />
"use strict";
var fs = require("fs");
var path = require("path");
var Q = require("q");
var DependencyDataWrapper = require("./utils/dependencyDataWrapper");
var protocol = require("./elevatedInstallerProtocol");
var resources = require("./resources/resourceManager");
var tacoUtils = require("taco-utils");
var ExitCode = protocol.ExitCode;
var utilHelper = tacoUtils.UtilHelper;
/*
 * Takes care of the actual installation work for the third-party dependencies (parsing and validating the config file, instantiating specialized installers, running installers).
 */
var InstallerRunner = (function () {
    function InstallerRunner(configFilePath, logger, metadataFilePath) {
        this.installerErrorFlag = false;
        this.dependenciesDataWrapper = metadataFilePath ? new DependencyDataWrapper(metadataFilePath) : new DependencyDataWrapper();
        this.configFile = configFilePath;
        this.logger = logger;
    }
    InstallerRunner.prototype.run = function () {
        var _this = this;
        return tacoUtils.TelemetryHelper.generate("InstallerRunner", function (telemetry) {
            var self = _this;
            return Q({})
                .then(function () {
                telemetry.step("parseInstallConfig");
                self.parseInstallConfig(telemetry);
            })
                .then(function () {
                telemetry.step("runInstallers");
                return self.runInstallers();
            })
                .then(function () {
                // If we reach this point, it means we ran the installers. Verify if there was an installation error and return appropriately.
                telemetry.step("runInstallersFinished").add("installerErrorFlag", self.installerErrorFlag, /*isPii*/ false);
                if (self.installerErrorFlag) {
                    return ExitCode.CompletedWithErrors;
                }
                return ExitCode.Success;
            })
                .catch(function (err) {
                // If we reach this point, it either means we had an unknown error or a config file validation error. Both cases have a return code of FatalError.
                telemetry.step("catch").add("errorMessage", err.message, /*isPii*/ false);
                self.logger.logError(err.message);
                return ExitCode.FatalError;
            });
        });
    };
    InstallerRunner.prototype.parseInstallConfig = function (telemetry) {
        var self = this;
        var parsedData = null;
        if (!fs.existsSync(this.configFile)) {
            throw new Error(resources.getString("InstallConfigNotFound", this.configFile));
        }
        try {
            parsedData = require(this.configFile);
        }
        catch (err) {
            throw new Error(resources.getString("InstallConfigMalformed"));
        }
        if (!parsedData.dependencies) {
            throw new Error(resources.getString("InstallConfigMalformed"));
        }
        var installPaths = [];
        this.missingDependencies = [];
        parsedData.dependencies.forEach(function (value) {
            // Verify the dependency id exists
            if (!self.dependenciesDataWrapper.dependencyExists(value.id)) {
                throw new Error(resources.getString("UnknownDependency", value.id));
            }
            // Verify the version exists for the dependency
            if (!self.dependenciesDataWrapper.versionExists(value.id, value.version)) {
                throw new Error(resources.getString("UnknownVersion", value.id, value.version));
            }
            // If an install destination is present, validate it
            if (value.installDestination) {
                // Verify the path is valid
                var resolvedPath = path.resolve(value.installDestination);
                if (!utilHelper.isPathValid(resolvedPath)) {
                    throw new Error(resources.getString("InvalidInstallPath", value.displayName, value.installDestination));
                }
                // Verify that the destination folder is empty if it already exists
                if (fs.existsSync(value.installDestination)) {
                    var dirItems = fs.readdirSync(value.installDestination);
                    if (dirItems.length > 0) {
                        // For Darwin platform, the directory can contain a ".DS_Store" file, which we need to ignore (the directory is essentially empty in that case)
                        if (process.platform !== "darwin" || dirItems.length !== 1 || dirItems[0] !== ".DS_Store") {
                            throw new Error(resources.getString("PathNotEmpty", value.displayName, value.installDestination));
                        }
                    }
                }
                // Verify that this path is not already used by another dependency
                var dependencyWithSamePath;
                var isPathUnique = !installPaths.some(function (previousInstallPath) {
                    var path1 = path.resolve(previousInstallPath.path);
                    var path2 = path.resolve(value.installDestination);
                    if (path1 === path2) {
                        dependencyWithSamePath = previousInstallPath.displayName;
                        return true;
                    }
                    return false;
                });
                if (!isPathUnique) {
                    throw new Error(resources.getString("PathNotUnique", value.displayName, dependencyWithSamePath));
                }
                // Cache install path for the next dependency validations
                installPaths.push({ displayName: value.displayName, path: value.installDestination });
            }
            // At this point, the values appear valid, so proceed with the instantiation of the installer for this dependency
            var dependencyWrapper = {
                dependency: value,
                installer: self.instantiateInstaller(value)
            };
            // We want to know if the users like to change the default installation directory, or not, to improve the experience if neccesary
            var defaultInstallDirectory = self.dependenciesDataWrapper.getInstallDirectory(value.id, value.version);
            if (defaultInstallDirectory && value.installDestination) {
                var normalizedDefaultInstallDirectory = path.normalize(utilHelper.expandEnvironmentVariables(defaultInstallDirectory));
                var normalizedInstallDestination = path.normalize(value.installDestination);
                var isDefault = normalizedDefaultInstallDirectory === normalizedInstallDestination;
                telemetry.add("installDestination.isDefault", isDefault, /*isPii*/ false);
                telemetry.add("installDestination.path", normalizedInstallDestination, /*isPii*/ true);
            }
            else {
                telemetry.add("installDestination.defaultIsNull", !defaultInstallDirectory, /*isPii*/ false);
                telemetry.add("installDestination.destinationIsNull", !value.installDestination, /*isPii*/ false);
            }
            // Add the dependency to our list of dependencies to install
            self.missingDependencies.push(dependencyWrapper);
        });
    };
    InstallerRunner.prototype.instantiateInstaller = function (dependency) {
        var installerInfoToUse = this.dependenciesDataWrapper.getInstallerInfo(dependency.id, dependency.version);
        var installerSteps = this.dependenciesDataWrapper.getInstallerSteps(dependency.id, dependency.version);
        var installerRequirePath = path.join(__dirname, this.dependenciesDataWrapper.getInstallerPath(dependency.id));
        var installerConstructor = require(installerRequirePath);
        return new installerConstructor(installerInfoToUse, dependency.version, dependency.installDestination, this.logger, installerSteps);
    };
    InstallerRunner.prototype.runInstallers = function () {
        var self = this;
        var baseHeaderString = "";
        return tacoUtils.PromisesUtils.chain(this.missingDependencies, function (value) {
            self.logger.log(baseHeaderString + "<highlight>" + value.dependency.displayName + "</highlight>");
            // we need a newline after printing entry
            if (!baseHeaderString) {
                baseHeaderString = "<br/>";
            }
            return Q({})
                .then(function () { return value.installer.run(); })
                .catch(function (err) {
                self.installerErrorFlag = true;
                self.logger.logError(err.message);
            });
        });
    };
    return InstallerRunner;
})();
module.exports = InstallerRunner;

//# sourceMappingURL=installerRunner.js.map
