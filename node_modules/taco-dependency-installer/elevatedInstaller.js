/**
 *******************************************************
 *                                                     *
 *   Copyright (C) Microsoft. All rights reserved.     *
 *                                                     *
 *******************************************************
 */
/// <reference path="../typings/dependencyInstallerInterfaces.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/tacoUtils.d.ts" />
"use strict";
var net = require("net");
var Q = require("q");
var InstallerRunner = require("./installerRunner");
var installerUtils = require("./utils/installerUtils");
var protocol = require("./elevatedInstallerProtocol");
var tacoUtils = require("taco-utils");
var installerDataType = protocol.DataType;
var protocolExitCode = protocol.ExitCode;
var TacoGlobalConfig = tacoUtils.TacoGlobalConfig;
var tacoLogger = tacoUtils.Logger;
// Internal class for an ILogger specifically designed for the communication between the elevatedInstaller and the dependencyInstaller on Windows, which requires socket communication over a local server
var Win32Logger = (function () {
    function Win32Logger(socket) {
        this.socketHandle = socket;
    }
    Win32Logger.prototype.log = function (message) {
        installerUtils.sendData(this.socketHandle, message);
    };
    Win32Logger.prototype.logWarning = function (message) {
        installerUtils.sendData(this.socketHandle, message, installerDataType.Warning);
    };
    Win32Logger.prototype.logError = function (message) {
        installerUtils.sendData(this.socketHandle, message, installerDataType.Error);
    };
    Win32Logger.prototype.promptForEnvVariableOverwrite = function (name) {
        return installerUtils.promptForEnvVariableOverwrite(name, this.socketHandle);
    };
    return Win32Logger;
})();
// Internal class for an ILogger for communication between the elevatedInstaller and the dependencyInstaller on OSX
var DarwinLogger = (function () {
    function DarwinLogger() {
    }
    DarwinLogger.prototype.log = function (message) {
        tacoLogger.log(message);
    };
    DarwinLogger.prototype.logWarning = function (message) {
        tacoLogger.logWarning(message);
    };
    DarwinLogger.prototype.logError = function (message) {
        tacoLogger.logError(message);
    };
    DarwinLogger.prototype.promptForEnvVariableOverwrite = function (name) {
        return Q({});
    };
    return DarwinLogger;
})();
/*
 * Takes care of installing the missing third-party dependencies on the user's system. This file should be executed inside a separate process that has administrator privileges. DependencyInstaller.ts
 * is responsible for starting that elevated process.
 *
 * This script starts by parsing the installation configuration file that DependencyInstaller created in taco_home. The file contains information on what dependencies need to be installed. After
 * parsing and validating the content, specialized installers that know how to handle specific dependencies are instantiated. The user is then presented with a summary of what is about to be
 * installed, and is prompted for confirmation. The specialized installers are then run in order of prerequisites (for example, java needs to be installed before Android SDK). Finally, this process
 * exits with the proper exit code (exit codes are defined in ElevatedInstallerProtocol).
 *
 * Because this is a separate process, and because it is not possible to intercept the stdio of an elevated process from a non-elevated one, the communication between this and DependencyInstaller is
 * made via a local socket that this script connects to and that DependencyInstaller listens to.
 *
 * Note that this specific class only acts as the "entry point" of the elevated installer process, and is responsible for the communication with the dependency installer. The actual installation work
 * (parsing and validating the config file, instantiating specialized installers, running installers) is delegated to the InstallRunner class.
 */
var ElevatedInstaller = (function () {
    function ElevatedInstaller() {
        this.configFile = process.argv[2];
        this.parentSessionId = process.argv[3];
        this.socketPath = process.argv[4];
        // Deal with auto-accept prompts; we need to reset this value, because on Windows we launch the elevated installer through PowerShell, and doing it that way does not carry over the env of the
        // parent node.js process
        if (process.argv[5] === "true") {
            TacoGlobalConfig.noPrompt = true;
        }
    }
    ElevatedInstaller.prototype.run = function () {
        var _this = this;
        tacoUtils.Telemetry.init("TACO/dependencyInstaller", require("./package.json").version, { isOptedIn: this.parentSessionId !== "null" });
        tacoUtils.Telemetry.setSessionId(this.parentSessionId);
        tacoUtils.TelemetryHelper.generate("ElevatedInstaller", function (telemetry) {
            var self = _this;
            telemetry.step("prepareCommunications");
            _this.prepareCommunications()
                .then(function () {
                telemetry.step("installerRunner.run");
                var installerRunner = new InstallerRunner(self.configFile, self.logger);
                return installerRunner.run();
            })
                .then(function (code) {
                telemetry.step("exitProcessSuccesfully");
                self.exitProcess(code);
            })
                .catch(function (err) {
                // If we have an uncaught error, log it and exit with a FatalError code
                telemetry.step("exitProcessUnsuccesfully").addError(err);
                self.logger.logError(err.message);
                self.exitProcess(protocolExitCode.FatalError);
            });
        });
    };
    ElevatedInstaller.prototype.prepareCommunications = function () {
        var self = this;
        switch (process.platform) {
            case "win32":
                // Connect to the communication server
                return this.connectToServer()
                    .then(function () {
                    // Instantiate the logger
                    self.logger = new Win32Logger(self.socketHandle);
                });
            case "darwin":
                // Instantiate the logger
                this.logger = new DarwinLogger();
                return Q({});
            default:
                this.exitProcess(protocolExitCode.FatalError);
        }
    };
    ElevatedInstaller.prototype.connectToServer = function () {
        if (!this.socketPath) {
            // If we can't connect to the DependencyInstaller's server, the only way to let the DependencyInstaller know is via exit code
            this.exitProcess(protocolExitCode.CouldNotConnect);
        }
        else {
            var deferred = Q.defer();
            try {
                this.socketHandle = net.connect(this.socketPath, function () {
                    deferred.resolve({});
                });
            }
            catch (err) {
                // If we can't connect to the DependencyInstaller's server, the only way to let the DependencyInstaller know is via exit code
                this.exitProcess(protocolExitCode.CouldNotConnect);
            }
            return deferred.promise;
        }
    };
    ElevatedInstaller.prototype.exitProcess = function (code) {
        if (this.socketHandle) {
            this.socketHandle.end();
        }
        process.on("exit", function () { return process.exit(code); });
    };
    return ElevatedInstaller;
})();
var elevatedInstaller = new ElevatedInstaller();
elevatedInstaller.run();

//# sourceMappingURL=elevatedInstaller.js.map
