/**
  *******************************************************
  *                                                     *
  *   Copyright (C) Microsoft. All rights reserved.     *
  *                                                     *
  *******************************************************
  */
/// <reference path="../typings/dependencyInstallerInterfaces.d.ts" />
/// <reference path="../typings/Q.d.ts" />
/// <reference path="../typings/tacoUtils.d.ts" />
/// <reference path="../typings/toposort.d.ts" />
"use strict";
var childProcess = require("child_process");
var fs = require("fs");
var net = require("net");
var os = require("os");
var path = require("path");
var Q = require("q");
var toposort = require("toposort");
var wrench = require("wrench");
var DependencyDataWrapper = require("./utils/dependencyDataWrapper");
var installerProtocol = require("./elevatedInstallerProtocol");
var installerUtils = require("./utils/installerUtils");
var resources = require("./resources/resourceManager");
var tacoErrorCodes = require("./tacoErrorCodes");
var errorHelper = require("./tacoErrorHelper");
var tacoUtils = require("taco-utils");
var util = require("util");
var installerDataType = installerProtocol.DataType;
var installerExitCode = installerProtocol.ExitCode;
var logger = tacoUtils.Logger;
var loggerHelper = tacoUtils.LoggerHelper;
var TacoErrorCodes = tacoErrorCodes.TacoErrorCode;
var TacoGlobalConfig = tacoUtils.TacoGlobalConfig;
var utilHelper = tacoUtils.UtilHelper;
var TacoDependencyInstaller;
(function (TacoDependencyInstaller) {
    var DependencyInstaller = (function () {
        function DependencyInstaller(parentSessionId, dependenciesMetadataFilePath) {
            this.parentSessionId = parentSessionId;
            this.dependenciesDataWrapper = !!dependenciesMetadataFilePath ? new DependencyDataWrapper(dependenciesMetadataFilePath) : new DependencyDataWrapper();
            this.installConfigFilePath = path.join(utilHelper.tacoHome, DependencyInstaller.INSTALL_CONFIG_FILENAME);
        }
        DependencyInstaller.prototype.run = function (requirementsResult) {
            var _this = this;
            return tacoUtils.TelemetryHelper.generate("dependencyInstaller", function (telemetry) {
                telemetry.add("requirements", requirementsResult, /*isPii*/ false);
                if (process.platform !== "win32" && process.platform !== "darwin") {
                    return Q.reject(errorHelper.get(TacoErrorCodes.UnsupportedPlatform, process.platform));
                }
                // Parse 'cordova requirements' results and extract missing dependencies to end up with an array of IDs
                _this.parseMissingDependencies(requirementsResult);
                telemetry
                    .addWithPiiEvaluator("missingDependencies", _this.missingDependencies, function (value, name) { return name.indexOf(".installDestination") >= 0; })
                    .add("unsupportedMissingDependencies", _this.unsupportedMissingDependencies, /*isPii*/ false);
                // Warn the user for any dependencies for which installation is not supported
                _this.displayUnsupportedWarning();
                // If there are no supported missing dependencies, we are done
                if (!_this.missingDependencies.length) {
                    logger.log(resources.getString("NothingToInstall"));
                    logger.logLine();
                    return Q.resolve({});
                }
                // Sort the array of dependency IDs based on the order in which they need to be installed
                _this.sortDependencies();
                // Print a summary of what is about to be installed, Wait for user confirmation, then spawn the elevated process which will perform the installations
                var self = _this;
                telemetry.step("promptUserBeforeInstall");
                return _this.promptUserBeforeInstall()
                    .then(function (acceptedPrompt) {
                    logger.logLine();
                    loggerHelper.logSeparatorLine();
                    logger.logLine();
                    if (acceptedPrompt) {
                        telemetry.step("spawnElevatedInstaller");
                        return self.spawnElevatedInstaller();
                    }
                    else {
                        return Q.resolve(installerProtocol.ExitCode.RefusedPrompt);
                    }
                })
                    .then(function (exitCode) {
                    telemetry.step("printSummaryLine").add("exitCode", exitCode, /*isPii*/ false);
                    self.printSummaryLine(exitCode);
                });
            });
        };
        DependencyInstaller.prototype.parseMissingDependencies = function (cordovaChecksResult) {
            // Extract dependency IDs from Cordova results. Depending on whether we were able to require() Cordova or not, this result can be either a dictionary of ICordovaRequirement objects, or a string
            // representing the raw output of invoking 'cordova requirements'.
            var isString = typeof cordovaChecksResult === "string" || cordovaChecksResult instanceof String;
            var dependencyIds = isString ? this.parseFromString(cordovaChecksResult) : this.parseFromRawResult(cordovaChecksResult);
            // Initialize arrays
            this.unsupportedMissingDependencies = [];
            this.missingDependencies = [];
            // Process cordova results
            var self = this;
            dependencyIds.forEach(function (value) {
                if (self.canInstallDependency(value)) {
                    // Only add the dependency to our list if it is not an implicit dependency. An implicit dependency is a dependency that is installed as part of a different dependency, so no explicit
                    // processing is required. For example, android SDK packages are implicit, because they are considered a standalone dependency by Cordova but are installed as part of Android SDK in
                    // this dependency installer.
                    if (!self.dependenciesDataWrapper.isImplicit(value.id)) {
                        var versionToUse = value.metadata && value.metadata.version ? value.metadata.version : self.dependenciesDataWrapper.getFirstValidVersion(value.id);
                        var installPath = self.dependenciesDataWrapper.getInstallDirectory(value.id, versionToUse);
                        var expandedInstallPath = installPath ? path.resolve(utilHelper.expandEnvironmentVariables(installPath)) : null;
                        var dependencyInfo = {
                            id: value.id,
                            version: versionToUse,
                            displayName: self.dependenciesDataWrapper.getDisplayName(value.id),
                            licenseUrl: self.dependenciesDataWrapper.getLicenseUrl(value.id),
                            installDestination: expandedInstallPath
                        };
                        self.missingDependencies.push(dependencyInfo);
                    }
                }
                else {
                    self.unsupportedMissingDependencies.push(value);
                }
            });
        };
        DependencyInstaller.prototype.parseFromString = function (output) {
            // If we parse the output, we are going to be dealing with display names rather than IDs for the dependencies, so we need a dictionary mapping names to IDs. These are taken directly from Cordova,
            // so they need to be updated here if Cordova ever changes them.
            var namesToIds = {
                "Java JDK": "java",
                "Android SDK": "androidSdk",
                "Android target": "androidTarget",
                Gradle: "gradle"
            };
            // Extract the names of the missing dependencies by parsing the output of the command. Here is an example of the output that 'cordova requirements' gives:
            /*
                Requirements check results for android:
                Java JDK: installed 1.7.0
                Android SDK: installed
                Android target: not installed
                [Error: Please install Android target: "android-22".

                Hint: Open the SDK manager by running: C:\Program\ Files\ (x86)\Android\android-sdk-windows\tools\android.BAT
                You will require:
                1. "SDK Platform" for android-22
                2. "Android SDK Platform-tools (latest)
                3. "Android SDK Build-tools" (latest)]
                Gradle: not installed
                [Error: Could not find gradle wrapper within Android SDK. Might need to update your Android SDK. Looked here: C:\Program Files (x86)\Android\android-sdk-windows\tools\templates\gradle\wrapper]
                Some of requirements check failed
            */
            var dependencies = [];
            var re = /(.+?): not installed/g;
            var result = re.exec(output);
            while (result) {
                // The captured dependency name will be at index 1 of the result
                var dependencyName = result[1];
                var req = {
                    id: namesToIds[dependencyName] || dependencyName,
                    installed: false,
                    name: dependencyName
                };
                dependencies.push(req);
                result = re.exec(output);
            }
            return dependencies;
        };
        DependencyInstaller.prototype.parseFromRawResult = function (results) {
            var dependencies = [];
            Object.keys(results).forEach(function (key) {
                if (util.isArray(results[key])) {
                    // If the key is an array, it means the check was successful for this platform, so we add the results to our dependency IDs
                    dependencies = dependencies.concat(results[key].filter(function (value) {
                        // We only keep requirements that are not installed
                        return !value.installed;
                    }));
                }
            });
            return dependencies;
        };
        DependencyInstaller.prototype.canInstallDependency = function (cordovaDependencyResult) {
            // If there is no ID property, then we can't understand this cordova result
            if (!cordovaDependencyResult.id) {
                return false;
            }
            // Verify if this ID exists in our metadata
            if (!this.dependenciesDataWrapper.dependencyExists(cordovaDependencyResult.id)) {
                return false;
            }
            // If the dependency is implicit, we can install it
            if (this.dependenciesDataWrapper.isImplicit(cordovaDependencyResult.id)) {
                return true;
            }
            // If cordova is requesting a specific version we need additional verifications
            var requestedVersion = cordovaDependencyResult.metadata ? cordovaDependencyResult.metadata.version : null;
            if (requestedVersion) {
                // If Cordova requested a specific version, we support this dependency if we have an installer for that version, and that installer has an entry for the current platform
                return this.dependenciesDataWrapper.versionExists(cordovaDependencyResult.id, requestedVersion) && this.dependenciesDataWrapper.isSystemSupported(cordovaDependencyResult.id, requestedVersion);
            }
            else {
                // Cordova did not request a specific version, so look if we have at least one installer version that supports the user's platform
                return !!this.dependenciesDataWrapper.getFirstValidVersion(cordovaDependencyResult.id);
            }
        };
        DependencyInstaller.prototype.displayUnsupportedWarning = function () {
            var self = this;
            if (this.unsupportedMissingDependencies.length > 0) {
                logger.logWarning(resources.getString("UnsupportedDependenciesHeader"));
                this.unsupportedMissingDependencies.forEach(function (value) {
                    var displayName = value.name || value.id;
                    var version = value.metadata ? value.metadata.version : null;
                    if (!displayName) {
                        // This dependency doesn't have an ID nor a display name. The data returned by Cordova must be malformed, so skip printing this dependency.
                        return;
                    }
                    logger.log(resources.getString("DependencyLabel", displayName));
                    if (version) {
                        logger.log(resources.getString("DependencyVersion", version));
                    }
                    // If this is a known unsupported dependency for which we have additional info, print it here
                    var installHelp = self.dependenciesDataWrapper.getInstallHelp(value.id);
                    if (installHelp) {
                        logger.log(resources.getString("UnsupportedMoreInfo", installHelp));
                    }
                });
                logger.logLine();
            }
        };
        DependencyInstaller.prototype.sortDependencies = function () {
            var self = this;
            // Build a representation of the graph in a way that is understood by the toposort package
            var nodes = [];
            var edges = [];
            this.missingDependencies.forEach(function (dependency) {
                // A node is simply the ID of a dependency
                nodes.push(dependency.id);
                // An edge is an array containing 2 nodes which correspond to the start and the end of the edge
                var prerequisites = self.dependenciesDataWrapper.getPrerequisites(dependency.id);
                prerequisites.forEach(function (prereq) {
                    // Only create an edge if prereq is in the list of missing dependencies
                    var isPrereqMissing = self.missingDependencies.some(function (dep) {
                        return dep.id === prereq;
                    });
                    if (isPrereqMissing) {
                        edges.push([dependency.id, prereq]);
                    }
                });
            });
            // Sort the IDs; we reverse because toposort assumes the edges mean ancestry, when in our case they mean descendancy
            var sortedIds = toposort.array(nodes, edges).reverse();
            // Reorder the missing dependencies based on the sorted IDs
            this.missingDependencies.sort(function (a, b) {
                return sortedIds.indexOf(a.id) - sortedIds.indexOf(b.id);
            });
        };
        DependencyInstaller.prototype.promptUserBeforeInstall = function () {
            this.buildInstallConfigFile();
            var self = this;
            var needsLicenseAgreement = this.missingDependencies.some(function (value) {
                // Return true if at least one of the missing dependencies has a license url, false if not
                return !!value.licenseUrl;
            });
            logger.logLine();
            loggerHelper.logSeparatorLine();
            logger.logLine();
            logger.log(resources.getString("InstallingDependenciesHeader"));
            this.missingDependencies.forEach(function (value) {
                logger.log(resources.getString("DependencyLabel", value.displayName));
                logger.log(resources.getString("DependencyVersion", value.version));
                if (value.installDestination) {
                    logger.log(resources.getString("InstallDestination", value.installDestination));
                }
                if (value.licenseUrl) {
                    logger.log(resources.getString("DependencyLicense", value.licenseUrl));
                }
                // For download size and disk size, we need to fetch the underlying installer data
                var installerData = self.dependenciesDataWrapper.getInstallerInfo(value.id, value.version);
                if (installerData.downloadSize) {
                    logger.log(resources.getString("DownloadSize", installerData.downloadSize));
                }
                if (installerData.diskSize) {
                    logger.log(resources.getString("DiskSize", installerData.diskSize));
                }
            });
            logger.logLine();
            loggerHelper.logSeparatorLine();
            logger.logLine();
            logger.log(resources.getString("ModifyInstallPaths", this.installConfigFilePath));
            if (needsLicenseAgreement) {
                logger.log(resources.getString("LicenseAgreement"));
            }
            // If we accept prompts automatically, then return immediately
            if (TacoGlobalConfig.noPrompt) {
                return Q.resolve(true);
            }
            logger.log(resources.getString("InstallationProceedQuestion"));
            return installerUtils.promptUser(resources.getString("YesExampleString"))
                .then(function (answer) {
                if (answer.toLocaleLowerCase() === resources.getString("YesString")) {
                    return Q.resolve(true);
                }
                else {
                    return Q.resolve(false);
                }
            });
        };
        DependencyInstaller.prototype.buildInstallConfigFile = function () {
            try {
                if (fs.existsSync(this.installConfigFilePath)) {
                    fs.unlinkSync(this.installConfigFilePath);
                }
            }
            catch (err) {
                throw errorHelper.get(TacoErrorCodes.ErrorDeletingInstallConfig, this.installConfigFilePath);
            }
            try {
                // Create a JSON object wrapper around our array of missing dependencies
                var jsonWrapper = {
                    dependencies: this.missingDependencies
                };
                // Write the json object to the config file
                wrench.mkdirSyncRecursive(path.dirname(this.installConfigFilePath), 511); // 511 decimal is 0777 octal
                fs.writeFileSync(this.installConfigFilePath, JSON.stringify(jsonWrapper, null, 4));
            }
            catch (err) {
                throw errorHelper.get(TacoErrorCodes.ErrorCreatingInstallConfig, this.installConfigFilePath);
            }
        };
        DependencyInstaller.prototype.prepareCommunications = function () {
            var self = this;
            if (os.platform() === "win32") {
                // For Windows we need to prepare a local server to communicate with the elevated installer process
                return Q({})
                    .then(function () {
                    self.createServer();
                })
                    .then(function () {
                    return self.connectServer();
                });
            }
            return Q({});
        };
        DependencyInstaller.prototype.createServer = function () {
            var self = this;
            this.serverHandle = net.createServer(function (socket) {
                self.socketHandle = socket;
                socket.on("data", function (data) {
                    // Messages can sometimes be sent in close succession, which causes more than one message to be captured in a single "data" event. For this reason, we send
                    // a newline after each message, and here we perform a split on newline characters to make sure we process each message individually. For now, the messages
                    // are short enough that this works, but if messages ever start becoming bigger, we may end up in a situation where the last message is truncated an sent
                    // in 2 different "data" events. If this ever happens, we will need to modify this event handler logic to wait until we have received an outer closing
                    // curly brace before processing a message.
                    var dataArray = data.toString().split(os.EOL);
                    dataArray.forEach(function (value) {
                        if (!value) {
                            return;
                        }
                        var parsedData = JSON.parse(value);
                        switch (parsedData.dataType) {
                            case installerDataType.Prompt:
                                self.promptUser(parsedData.message);
                                break;
                            case installerDataType.Error:
                                logger.logError(parsedData.message);
                                break;
                            case installerDataType.Warning:
                                logger.logWarning(parsedData.message);
                                break;
                            case installerDataType.Log:
                                logger.log(parsedData.message);
                        }
                    });
                });
            });
        };
        DependencyInstaller.prototype.promptUser = function (msg) {
            var self = this;
            installerUtils.promptUser(msg)
                .then(function (answer) {
                self.socketHandle.write(answer);
            });
        };
        DependencyInstaller.prototype.connectServer = function () {
            var deferred = Q.defer();
            this.serverHandle.listen(DependencyInstaller.socketPath, function () {
                deferred.resolve({});
            });
            return deferred.promise;
        };
        DependencyInstaller.prototype.spawnElevatedInstaller = function () {
            switch (process.platform) {
                case "win32":
                    return this.spawnElevatedInstallerWin32();
                case "darwin":
                    return this.spawnElevatedInstallerDarwin();
                default:
                    return Q.reject(errorHelper.get(TacoErrorCodes.UnsupportedPlatform, process.platform));
            }
        };
        DependencyInstaller.prototype.spawnElevatedInstallerWin32 = function () {
            var self = this;
            // Set up the communication channels to talk with the elevated installer process
            return this.prepareCommunications()
                .then(function () {
                var deferred = Q.defer();
                var launcherPath = path.resolve(__dirname, "utils", "win32", "elevatedInstallerLauncher.ps1");
                var elevatedInstallerPath = path.resolve(__dirname, "elevatedInstaller.js");
                var command = "powershell";
                var args = [
                    "-executionpolicy",
                    "unrestricted",
                    "-file",
                    launcherPath,
                    utilHelper.quotesAroundIfNecessary(elevatedInstallerPath),
                    utilHelper.quotesAroundIfNecessary(self.installConfigFilePath),
                    self.parentSessionId,
                    utilHelper.quotesAroundIfNecessary(DependencyInstaller.socketPath),
                    TacoGlobalConfig.noPrompt ? "true" : "false" // When launching a child process inside PowerShell, the environment is not preserved, so we need to pass this value on the command line
                ];
                var cp = childProcess.spawn(command, args, { stdio: "ignore" }); // Note: To workaround a Powershell hang on Windows 7, we set the stdio to ignore, otherwise Powershell never returns
                cp.on("error", function (err) {
                    // Handle ENOENT if Powershell is not found
                    if (err.code === "ENOENT") {
                        deferred.reject(errorHelper.get(TacoErrorCodes.NoPowershell));
                    }
                    else {
                        deferred.reject(errorHelper.wrap(TacoErrorCodes.UnknownExitCode, err));
                    }
                });
                cp.on("exit", function (code) {
                    self.serverHandle.close(function () {
                        deferred.resolve(code);
                    });
                });
                return deferred.promise;
            });
        };
        DependencyInstaller.prototype.spawnElevatedInstallerDarwin = function () {
            var self = this;
            var deferred = Q.defer();
            var elevatedInstallerScript = path.resolve(__dirname, "elevatedInstaller.js");
            var command;
            var args;
            if (process.env.USER === "root") {
                command = "node";
                args = [];
            }
            else {
                // If we launch the process with sudo, we need to use the -E switch, which preserves the environment. By default, sudo clears the environment and replaces it with safe values, which means
                // the elevated process won't have access to variables such as ANDROID_HOME. We need to have access to those variables in the elevated installer, otherwise we will detect that the env
                // variables are not set and we will set them again.
                command = "sudo";
                args = ["-E", "node"];
            }
            args = args.concat([
                elevatedInstallerScript,
                utilHelper.quotesAroundIfNecessary(self.installConfigFilePath),
                self.parentSessionId
            ]);
            var cp = childProcess.spawn(command, args, { stdio: "inherit" });
            cp.on("error", function (err) {
                deferred.reject(errorHelper.wrap(TacoErrorCodes.UnknownExitCode, err));
            });
            cp.on("exit", function (code) {
                deferred.resolve(code);
            });
            return deferred.promise;
        };
        DependencyInstaller.prototype.printSummaryLine = function (code) {
            logger.logLine();
            loggerHelper.logSeparatorLine();
            logger.logLine();
            switch (code) {
                case installerExitCode.CompletedWithErrors:
                    logger.logError(resources.getString("InstallCompletedWithErrors"));
                    break;
                case installerExitCode.CouldNotConnect:
                    throw errorHelper.get(TacoErrorCodes.CouldNotConnect);
                case installerExitCode.NoAdminRights:
                    throw errorHelper.get(TacoErrorCodes.NoAdminRights);
                case installerExitCode.Success:
                    logger.log(resources.getString("InstallCompletedSuccessfully"));
                    break;
                case installerExitCode.FatalError:
                    throw errorHelper.get(TacoErrorCodes.FatalError);
                case installerExitCode.RefusedPrompt:
                    logger.log(resources.getString("LicenseAgreementRefused"));
                    break;
                default:
                    throw errorHelper.get(TacoErrorCodes.UnknownExitCode);
            }
            if (code === installerExitCode.Success || code === installerExitCode.CompletedWithErrors) {
                logger.log(resources.getString("RestartCommandPrompt"));
            }
        };
        DependencyInstaller.INSTALL_CONFIG_FILENAME = "installConfig.json";
        DependencyInstaller.socketPath = path.join("\\\\?\\pipe", utilHelper.tacoHome, "installer.sock");
        return DependencyInstaller;
    })();
    TacoDependencyInstaller.DependencyInstaller = DependencyInstaller;
})(TacoDependencyInstaller || (TacoDependencyInstaller = {}));
module.exports = TacoDependencyInstaller;

//# sourceMappingURL=dependencyInstaller.js.map
