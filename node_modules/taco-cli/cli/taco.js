// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/cordovaExtensions.d.ts" />
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/tacoHelpArgs.d.ts"/>
/// <reference path="../../typings/tacoKits.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
"use strict";
var path = require("path");
var Q = require("q");
var resources = require("../resources/resourceManager");
var Settings = require("./utils/settings");
var tacoUtility = require("taco-utils");
var CheckForNewerVersion = require("./utils/checkForNewerVersion");
var CliTelemetryHelper = require("./utils/cliTelemetryHelper");
var commands = tacoUtility.Commands;
var CommandsFactory = commands.CommandFactory;
var CordovaWrapper = tacoUtility.CordovaWrapper;
var logger = tacoUtility.Logger;
var LogLevel = tacoUtility.LogLevel;
var ProjectHelper = tacoUtility.ProjectHelper;
var TacoGlobalConfig = tacoUtility.TacoGlobalConfig;
var telemetry = tacoUtility.Telemetry;
var telemetryHelper = tacoUtility.TelemetryHelper;
var UtilHelper = tacoUtility.UtilHelper;
/**
 * Taco
 *
 * Main Taco class
 */
var Taco = (function () {
    function Taco() {
    }
    /**
     * Runs taco with command line args
     */
    Taco.run = function () {
        Settings.loadSettings().fail(function (err) {
            // This is the first time TACO is invoked, so print the logo. Logo gets printed as a side effect of the require. Require caching will make sure we don't execute it twice in the one session.
            require("./logo");
            // Print the third-party disclaimer, and save the global setting for this session to prevent printing the disclaimer again
            logger.log(resources.getString("ThirdPartyDisclaimer"));
            return Settings.saveSettings({});
        }).then(function (settings) {
            return telemetry.init("TACO", require("../package.json").version);
        }).then(function () {
            TacoGlobalConfig.lang = "en"; // Disable localization for now so we don't get partially localized content.
            // We check if there is a new TACO version available, and if so, we print a message before exiting the application
            new CheckForNewerVersion().showOnExitAndIgnoreFailures();
            var parsedArgs = Taco.parseArgs(process.argv.slice(2));
            return Taco.runWithParsedArgs(parsedArgs)
                .catch(function (reason) {
                // set exit code to report error
                process.on("exit", function () { process.exit(1); });
                // Pretty print errors
                if (reason) {
                    if (reason.isTacoError) {
                        if (reason.errorLevel === tacoUtility.TacoErrorLevel.Warning) {
                            logger.logWarning(reason.message);
                        }
                        else {
                            logger.logError(reason.toString());
                        }
                    }
                    else {
                        var toPrint = reason.toString();
                        // If we have a loglevel of diagnostic, and there is a stack, replace the error message with the stack (the stack contains the error message already)
                        if (TacoGlobalConfig.logLevel === LogLevel.Diagnostic && reason.stack) {
                            toPrint = reason.stack;
                        }
                        logger.logError(toPrint);
                    }
                    if (parsedArgs.command) {
                        // Send command failure telemetry for valid TACO commands
                        // Any invalid command will be routed to Cordova and 
                        // telemetry events for such commands are sent as "routedCommand" telemetry events
                        return CliTelemetryHelper.getCurrentProjectTelemetryProperties().then(function (telemetryProperties) {
                            telemetryHelper.sendCommandFailureTelemetry(parsedArgs.commandName, reason, telemetryProperties, parsedArgs.args);
                        });
                    }
                }
            });
        }).finally(function () {
            // Make sure to leave a line after the last of our output
            logger.logLine();
            telemetry.sendPendingData();
        }).done();
    };
    /**
     * runs taco with parsed args ensuring proper initialization
     */
    Taco.runWithParsedArgs = function (parsedArgs) {
        return Q({})
            .then(function () {
            ProjectHelper.cdToProjectRoot();
            // if no command found that can handle these args, route args directly to Cordova
            if (parsedArgs.command) {
                return parsedArgs.command.run(parsedArgs.args)
                    .then(function (telemetryProperties) {
                    // Send command success telemetry
                    telemetryHelper.sendCommandSuccessTelemetry(parsedArgs.commandName, telemetryProperties, parsedArgs.args);
                });
            }
            logger.logWarning(resources.getString("TacoCommandPassthrough"));
            var routeToCordovaEvent = new telemetry.TelemetryEvent(telemetry.appName + "/routedcommand");
            telemetryHelper.addTelemetryEventProperty(routeToCordovaEvent, "argument", parsedArgs.args, true);
            return CordovaWrapper.cli(parsedArgs.args).then(function (output) {
                routeToCordovaEvent.properties["success"] = "true";
                telemetry.send(routeToCordovaEvent);
                return Q(output);
            }, function (reason) {
                routeToCordovaEvent.properties["success"] = "false";
                telemetry.send(routeToCordovaEvent);
                return Q.reject(reason);
            });
        });
    };
    /**
     * runs taco with raw args ensuring proper initialization
     */
    Taco.runWithArgs = function (args) {
        return Taco.runWithParsedArgs(Taco.parseArgs(args));
    };
    Taco.parseArgs = function (args) {
        // Initialize global settings
        args = UtilHelper.initializeLogLevel(args);
        args = UtilHelper.initializeNoPrompt(args);
        var commandName = null;
        var commandArgs = null;
        // if version flag found, mark input as version and continue
        if (UtilHelper.tryParseVersionArgs(args)) {
            commandName = "version";
            commandArgs = [];
        }
        else {
            var helpArgs = UtilHelper.tryParseHelpArgs(args);
            if (helpArgs) {
                commandName = "help";
                commandArgs = helpArgs.helpTopic ? [helpArgs.helpTopic] : [];
            }
            else {
                commandName = args[0] || "help";
                commandArgs = args.slice(1);
            }
        }
        var commandsFactory = new CommandsFactory(path.join(__dirname, "./commands.json"));
        var command = commandsFactory.getTask(commandName, commandArgs, __dirname);
        return { command: command, args: command ? commandArgs : args, commandName: commandName || command.name };
    };
    return Taco;
}());
module.exports = Taco;

//# sourceMappingURL=taco.js.map
