// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
"use strict";
/// <reference path="../../../typings/node.d.ts" />
/// <reference path="../../../typings/request.d.ts" />
/* This is the ionic implementation of this feature: https://github.com/driftyco/ionic-cli/blob/195c06140d0c8179758d778ea78980e2371dfba6/lib/cli.js */
var tacoUtility = require("taco-utils");
var Q = require("q");
var resources = require("../../resources/resourceManager");
var request = require("request");
var settingsManager = require("../utils/settings");
var semver = require("semver");
var logger = tacoUtility.Logger;
var CheckForNewerVersion = (function () {
    function CheckForNewerVersion(tacoCliNpmRepositoryUrl, packageFilePath) {
        if (tacoCliNpmRepositoryUrl === void 0) { tacoCliNpmRepositoryUrl = "http://registry.npmjs.org/taco-cli/latest"; }
        if (packageFilePath === void 0) { packageFilePath = "../../package.json"; }
        this.millisecondsInAnHour = 60 * 60 * 1000;
        this.maximumCheckIntervalInHours = 4;
        this.millisecondsUntilTimeout = 5 * 1000; /* We want this to be high, as to have time to get the response back,
            but not very high, because we'll be blocking the user console if this takes too long */
        this.tacoCliNpmRepositoryUrl = tacoCliNpmRepositoryUrl;
        this.packageFilePath = packageFilePath;
    }
    CheckForNewerVersion.prototype.showOnExit = function () {
        /* Pseudo-code:
            1. Get last time check was done from TacoSettings.json
            2. If last time check was done was long ago, then continue, if not stop.
            3. Obtain last version currently released from http://registry.npmjs.org/taco-cli/latest
            4. If current version < last released version then schedule printting warning message on beforeExit.
            5. Update the last time check was done on TacoSettings.json to Date.now()
        */
        var _this = this;
        return this.isCheckForUpdateNeeded() // 1.
            .then(function (isCheckForUpdateNeeded) {
            if (isCheckForUpdateNeeded) {
                return _this.getLatestVersion() // 3.
                    .then(function (latestVersion) { return _this.printVersionWarningIfNeccesary(latestVersion); }) // 4.
                    .then(function () { return _this.updateLastTimeCheckWasDone(); }); // 5.
            }
            else {
                return Q.resolve(isCheckForUpdateNeeded);
            }
        });
    };
    CheckForNewerVersion.prototype.showOnExitAndIgnoreFailures = function () {
        try {
            this.showOnExit().catch(tacoUtility.UtilHelper.emptyMethod).done();
        }
        catch (e) {
        }
    };
    CheckForNewerVersion.prototype.isCheckForUpdateNeeded = function () {
        var self = this;
        return settingsManager.loadSettings().then(function (settings) {
            var currentDate = new Date();
            if (settings.lastCheckForNewerVersionTimestamp) {
                var millisecondSinceLastCheck = currentDate.getTime() - new Date(settings.lastCheckForNewerVersionTimestamp).getTime();
                var isCheckForUpdateNeeded = millisecondSinceLastCheck > self.maximumCheckIntervalInHours * self.millisecondsInAnHour;
                // FOR DEBUGGING: The next line is only used while debugging this feature
                // logger.log("Last Check Time" + lastCheckTime + "Current date = " + currentDate + ", Last checked date = " + settings.lastCheckForNewerVersionTimestamp);
                return isCheckForUpdateNeeded;
            }
            else {
                // If the setting doesn't exist, we assume we've never checked it before
                return true;
            }
        }).fail(function () { return true; });
    };
    CheckForNewerVersion.prototype.getLatestVersion = function () {
        var deferredLatestVersion = Q.defer();
        var proxy = process.env.PROXY || process.env.http_proxy || null;
        request({ url: this.tacoCliNpmRepositoryUrl, json: true, proxy: proxy, timeout: this.millisecondsUntilTimeout }, function (error, response, body) {
            try {
                if (!error && response.statusCode === 200 && body.version) {
                    var latestVersion = body.version;
                    deferredLatestVersion.resolve(latestVersion);
                }
                else {
                    deferredLatestVersion.reject("error = " + error + ", status code = " + (response ? response.statusCode : "none") + ", body = " + body);
                }
            }
            catch (e) {
                deferredLatestVersion.reject(e);
            }
        });
        return deferredLatestVersion.promise;
    };
    CheckForNewerVersion.prototype.printVersionWarningIfNeccesary = function (latestVersion) {
        var installedVersion = require(this.packageFilePath).version;
        if (semver.gt(latestVersion, installedVersion)) {
            // We want to print this just before exiting, so we subscribe to beforeExit: https://nodejs.org/api/process.html#process_event_exit
            process.once("beforeExit", function () {
                logger.log(resources.getString("NewerTacoCLIVersionAvailable", installedVersion, latestVersion));
            });
        }
        else {
        }
    };
    CheckForNewerVersion.prototype.updateLastTimeCheckWasDone = function () {
        return settingsManager.updateSettings(function (settings) { return settings.lastCheckForNewerVersionTimestamp = Date.now(); });
    };
    return CheckForNewerVersion;
}());
module.exports = CheckForNewerVersion;

//# sourceMappingURL=checkForNewerVersion.js.map
