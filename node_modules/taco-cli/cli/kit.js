// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/cordovaExtensions.d.ts" />
/// <reference path="../../typings/nameDescription.d.ts" />
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/nopt.d.ts" />
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/tacoKits.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var assert = require("assert");
var fs = require("fs");
var path = require("path");
var Q = require("q");
var semver = require("semver");
var util = require("util");
var errorHelper = require("./tacoErrorHelper");
var kitHelper = require("./utils/kitHelper");
var readline = require("readline");
var resources = require("../resources/resourceManager");
var TacoErrorCodes = require("./tacoErrorCodes");
var tacoUtility = require("taco-utils");
var commands = tacoUtility.Commands;
var CordovaWrapper = tacoUtility.CordovaWrapper;
var CordovaHelper = tacoUtility.CordovaHelper;
var logger = tacoUtility.Logger;
var LoggerHelper = tacoUtility.LoggerHelper;
var ProjectHelper = tacoUtility.ProjectHelper;
var TelemetryHelper = tacoUtility.TelemetryHelper;
var utils = tacoUtility.UtilHelper;
var NpmHelper = tacoUtility.NpmHelper;
var ProjectComponentType;
(function (ProjectComponentType) {
    ProjectComponentType[ProjectComponentType["Unknown"] = -1] = "Unknown";
    ProjectComponentType[ProjectComponentType["Platform"] = 0] = "Platform";
    ProjectComponentType[ProjectComponentType["Plugin"] = 1] = "Plugin";
})(ProjectComponentType || (ProjectComponentType = {}));
/**
 * kit
 *
 * handles "taco kit"
 */
var Kit = (function (_super) {
    __extends(Kit, _super);
    function Kit() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = "kit";
        this.subcommands = [
            {
                // Change kit or CLI
                name: "select",
                run: function () { return _this.select(); }
            },
            {
                // List kits
                name: "list",
                run: function () { return _this.list(); },
                canHandleArgs: function () { return true; }
            }
        ];
    }
    /**
     * Prompts the user with the prompt string and returns the response
     */
    Kit.promptUser = function (prompt) {
        var deferred = Q.defer();
        var yesOrNoHandler = Kit.yesOrNoHandler ? Kit.yesOrNoHandler : readline.createInterface({ input: process.stdin, output: process.stdout });
        yesOrNoHandler.question(prompt, function (answer) {
            yesOrNoHandler.close();
            deferred.resolve(answer);
        });
        return deferred.promise;
    };
    /**
     * Prompts for update and updates the project on a affirmative response
     */
    Kit.promptAndUpdateProject = function (editParams, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates) {
        if (platformVersionUpdates === void 0) { platformVersionUpdates = null; }
        if (pluginVersionUpdates === void 0) { pluginVersionUpdates = null; }
        logger.logLine();
        return Kit.promptUser(resources.getString("CommandKitSelectProjectUpdatePrompt"))
            .then(function (answer) {
            if (answer && answer.length > 0) {
                answer = answer.toLowerCase();
                if (resources.getString("PromptResponseYes").toLowerCase().split("\n").indexOf(answer) !== -1) {
                    logger.logLine();
                    return Kit.updateProject(editParams, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates);
                }
                else {
                    return Q.reject(errorHelper.getWarning("WarnProjectUpdateAborted"));
                }
            }
        });
    };
    /**
     * Get kit title
     */
    Kit.getKitTitle = function (kitId, kitInfo) {
        var name = util.format("<kitid>%s</kitid>", kitId);
        if (!!kitInfo.default) {
            return util.format("%s <defaultkit>(%s)</defaultkit>", name, resources.getString("CommandKitListDefaultKit"));
        }
        else if (!!kitInfo.deprecated) {
            return util.format("%s <deprecatedkit>(%s) </deprecatedkit>", name, resources.getString("CommandKitListDeprecatedKit"));
        }
        return name;
    };
    Kit.generateTelemetryProperties = function (commandData, subCommand) {
        return Q.when(TelemetryHelper.addPropertiesFromOptions({ subCommand: TelemetryHelper.telemetryProperty(subCommand) }, Kit.KNOWN_OPTIONS, commandData.options, ["kit", "cordova"]));
    };
    /**
     * Get kit description
     */
    Kit.getKitDescription = function (kitInfo) {
        var kitDefaultDescription = "";
        if (kitInfo["cordova-cli"]) {
            kitDefaultDescription = resources.getString("CommandKitListDefaultDescription", kitInfo["cordova-cli"]);
        }
        kitDefaultDescription = kitInfo.description || kitDefaultDescription;
        if (!!kitInfo.default) {
            return util.format("%s <defaultkit>%s</defaultkit>", kitDefaultDescription, resources.getString("CommandKitListDefaultKitDescSuffix"));
        }
        else if (!!kitInfo.deprecated) {
            return util.format("%s <deprecatedkit>%s</deprecatedkit>", kitDefaultDescription, resources.getString("CommandKitListDeprecatedKitDescSuffix"));
        }
        else {
            return kitDefaultDescription;
        }
    };
    /**
     * Pretty prints title and description of all the known kits
     * Order is :
     * <current_kit> if within a Taco kit project
     * <default_kit>
     * <available_kit_1>
     * <available_kit_2>
     * <available_kit_3>
     * ...
     * <deprecated_kit_1>
     * <deprecated_kit_2>
     * ...
     */
    Kit.printAllKits = function () {
        var defaultKitDesc, currentKitDesc;
        var kitsToPrint = [];
        var deprecatedKits = [];
        var availableKits = [];
        var currentKitId = "";
        return Kit.getCurrentKitInfo().then(function (kitInfo) {
            currentKitId = kitInfo.kitId;
            var logLine = false;
            if (kitInfo.kitId) {
                logger.log(resources.getString("CommandKitListCurrentKit", kitInfo.kitId));
                logLine = true;
            }
            if (kitInfo.cordovaCliVersion) {
                logger.log(resources.getString("CommandKitListCurrentCordovaCLI", kitInfo.cordovaCliVersion));
                logLine = true;
            }
            if (logLine) {
                logger.logLine();
            }
            return Q.resolve({});
        })
            .then(function () {
            return kitHelper.getKitMetadata().then(function (meta) {
                return Q.all(Object.keys(meta.kits).map(function (kitId) {
                    return kitHelper.getKitInfo(kitId).then(function (kitInfo) {
                        var kitNameDescription = {
                            name: util.format("<kitid>%s</kitid>", kitId),
                            description: Kit.getKitDescription(kitInfo)
                        };
                        if (kitId === currentKitId) {
                            currentKitDesc = kitNameDescription;
                        }
                        else {
                            if (!!kitInfo.default) {
                                defaultKitDesc = kitNameDescription;
                            }
                            else if (!!kitInfo.deprecated) {
                                deprecatedKits.push(kitNameDescription);
                            }
                            else {
                                availableKits.push(kitNameDescription);
                            }
                        }
                        return Q.resolve({});
                    });
                }));
            });
        })
            .then(function () {
            if (currentKitDesc) {
                kitsToPrint.push(currentKitDesc);
            }
            if (defaultKitDesc) {
                kitsToPrint.push(defaultKitDesc);
            }
            kitsToPrint.push.apply(kitsToPrint, availableKits);
            kitsToPrint.push.apply(kitsToPrint, deprecatedKits);
            logger.log(resources.getString("CommandKitList"));
            logger.logLine();
            LoggerHelper.logNameDescriptionTable(kitsToPrint);
            return Q.resolve({});
        });
    };
    /**
     * Pretty prints the Kit name and description info
     */
    Kit.printKitNameAndDescription = function (kitId, kitInfo) {
        var title = Kit.getKitTitle(kitId, kitInfo);
        var kitDescription = Kit.getKitDescription(kitInfo);
        logger.log(util.format("%s<underline/>", title));
        logger.log(kitDescription);
    };
    /**
     * Pretty prints the Cordova CLI version info
     */
    Kit.printCordovaCliVersion = function (kitInfo) {
        if (kitInfo["cordova-cli"]) {
            logger.logLine();
            logger.log(resources.getString("CommandKitListCordovaCliForKit", kitInfo["cordova-cli"]));
            logger.logLine();
        }
    };
    /**
     * Pretty prints the platform version override info
     */
    Kit.printPlatformOverrideInfo = function (kitInfo, valuesIndent) {
        if (kitInfo.platforms) {
            logger.log(resources.getString("CommandKitListPlatformOverridesForKit"));
            logger.logLine();
            LoggerHelper.logNameDescriptionTable(Object.keys(kitInfo.platforms).map(function (platformName) {
                return {
                    name: platformName,
                    description: kitInfo.platforms[platformName].version || kitInfo.platforms[platformName].src
                };
            }), LoggerHelper.DEFAULT_INDENT, valuesIndent);
            logger.logLine();
        }
    };
    /**
     * Pretty prints the plugin version override info
     */
    Kit.printPluginOverrideInfo = function (kitInfo, valuesIndent) {
        if (kitInfo.plugins) {
            logger.log(resources.getString("CommandKitListPluginOverridesForKit"));
            logger.logLine();
            LoggerHelper.logNameDescriptionTable(Object.keys(kitInfo.plugins).map(function (pluginId) {
                return {
                    name: pluginId,
                    description: kitInfo.plugins[pluginId].version || kitInfo.plugins[pluginId].src
                };
            }), LoggerHelper.DEFAULT_INDENT, valuesIndent);
            logger.logLine();
        }
    };
    /**
     * Prints the release notes information for a kit
     */
    Kit.printReleaseNotesInformation = function (kitInfo) {
        if (kitInfo.releaseNotesUri && kitInfo.releaseNotesUri.length > 0) {
            logger.logLine();
            logger.log(resources.getString("CommandKitListReleaseNotes", kitInfo.releaseNotesUri));
        }
    };
    /**
     * Validates the file path passed. Throw appropriate errors if path passed is invalid.
     */
    Kit.validateJsonFilePath = function (jsonFilePath) {
        assert(jsonFilePath);
        // Make sure the specified path is valid
        if (!utils.isPathValid(jsonFilePath)) {
            throw errorHelper.get(TacoErrorCodes.ErrorInvalidPath, jsonFilePath);
        }
        if (path.extname(jsonFilePath).toLowerCase() !== ".json") {
            throw errorHelper.get(TacoErrorCodes.ErrorInvalidJsonFilePath, jsonFilePath);
        }
        if (fs.existsSync(jsonFilePath)) {
            return Kit.promptUser(resources.getString("CommandKitListJsonOverwritePrompt", jsonFilePath))
                .then(function (answer) {
                if (answer && answer.length > 0) {
                    answer = answer.toLowerCase();
                    logger.logLine();
                    if (resources.getString("PromptResponseYes").split("\n").indexOf(answer) === -1) {
                        throw resources.getString("ErrorOperationCancelled");
                    }
                }
            });
        }
        utils.createDirectoryIfNecessary(path.dirname(jsonFilePath));
        return Q.resolve({});
    };
    /**
     * Save the metadata Json to path provided as argument to "--json" option
     */
    Kit.writeMetadataJsonFile = function (commandData) {
        var deferred = Q.defer();
        var jsonFilePath = commandData.options["json"];
        if (!jsonFilePath) {
            jsonFilePath = path.join(utils.tacoHome, Kit.DEFAULT_METADATA_FILENAME);
        }
        return Kit.validateJsonFilePath(jsonFilePath)
            .then(function () {
            return kitHelper.getKitMetadata();
        })
            .then(function (meta) {
            return ProjectHelper.createJsonFileWithContents(jsonFilePath, meta.kits);
        })
            .then(function () {
            logger.log(resources.getString("CommandKitListJsonFileStatus", jsonFilePath));
            return Q.resolve({});
        });
    };
    Kit.getLongestPlatformPluginLength = function (platforms, plugins) {
        var longest = 0;
        if (platforms) {
            longest = platforms.reduce(function (max, platformName) {
                return Math.max(max, platformName.length);
            }, longest);
        }
        if (plugins) {
            longest = plugins.reduce(function (max, pluginId) {
                return Math.max(max, pluginId.length);
            }, longest);
        }
        return longest;
    };
    /**
     * Pretty prints information (title, description, Cordova CLI version,
     * plugin/platform override info regardng a single kit
     */
    Kit.printKit = function (kitId) {
        return kitHelper.getKitInfo(kitId).then(function (kitInfo) {
            var indent = LoggerHelper.getDescriptionColumnIndent(Kit.getLongestPlatformPluginLength(kitInfo.platforms ? Object.keys(kitInfo.platforms) : null, kitInfo.plugins ? Object.keys(kitInfo.plugins) : null));
            Kit.printKitNameAndDescription(kitId, kitInfo);
            Kit.printCordovaCliVersion(kitInfo);
            Kit.printPlatformOverrideInfo(kitInfo, indent);
            Kit.printPluginOverrideInfo(kitInfo, indent);
            Kit.printReleaseNotesInformation(kitInfo);
        });
    };
    /**
     * Pretty prints the current Kit/Cordova CLI info
     */
    Kit.getCurrentKitInfo = function () {
        var deferred = Q.defer();
        return ProjectHelper.getProjectInfo().then(function (projectInfo) {
            deferred.resolve({ kitId: projectInfo.tacoKitId, cordovaCliVersion: projectInfo.cordovaCliVersion });
            return deferred.promise;
        });
    };
    /**
     * Updates the project compoenents - plugins/platforms added to the project - Removes and adds platforms
     */
    Kit.updateComponents = function (editParams, components, componentType) {
        assert(componentType === ProjectComponentType.Platform || componentType === ProjectComponentType.Plugin);
        if (!components || Object.keys(components).length === 0) {
            return Q({});
        }
        if (componentType === ProjectComponentType.Platform) {
            logger.log(resources.getString("CommandKitSelectStatusUpdatingPlatforms"));
            var platformOpts = { usegit: false, link: "", save: true };
            // Remove all the updatable platforms and re-add them
            return CordovaWrapper.platform("remove", null, Object.keys(components), platformOpts)
                .then(function () {
                // Do not save in the case of updating to CLI project
                platformOpts.save = editParams.isKitProject;
                return tacoUtility.PromisesUtils.chain(Object.keys(components), function (componentName) {
                    // No override on the case of CLI project update - Cordova CLI gets its pinned version
                    var componentOverride = editParams.isKitProject ? componentName + "@" + components[componentName] : componentName;
                    return CordovaWrapper.platform("add", null, [componentOverride], platformOpts);
                });
            });
        }
        else {
            logger.log(resources.getString("CommandKitSelectStatusUpdatingPlugins"));
            // Remove all the updatable plugins and re-add them
            var pluginOpts = { save: true };
            return CordovaWrapper.plugin("remove", null, Object.keys(components))
                .then(function () {
                // Do not save in the case of updating to CLI project
                pluginOpts.save = editParams.isKitProject;
                return tacoUtility.PromisesUtils.chain(Object.keys(components), function (componentName) {
                    // No override on the case of CLI project update - Cordova CLI gets its pinned version
                    var componentOverride = editParams.isKitProject ? componentName + "@" + components[componentName] : componentName;
                    return CordovaWrapper.plugin("add", null, [componentOverride], pluginOpts);
                });
            });
        }
    };
    /**
     * Updates the platforms and plugins added to the project - after a kit/cli change
     */
    Kit.updateProject = function (editParams, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates) {
        if (platformVersionUpdates === void 0) { platformVersionUpdates = null; }
        if (pluginVersionUpdates === void 0) { pluginVersionUpdates = null; }
        logger.log(resources.getString("CommandKitSelectStatusUpdatingTacoJson"));
        // First, update the taco.json to reflect the new CLI/kit version
        // Then go ahead and update the platforms and plugins
        return kitHelper.editTacoJsonFile(editParams)
            .then(function () {
            return Kit.updateComponents(editParams, platformVersionUpdates || installedPlatformVersions, ProjectComponentType.Platform);
        }).then(function () {
            return Kit.updateComponents(editParams, pluginVersionUpdates || installedPluginVersions, ProjectComponentType.Plugin);
        });
    };
    /**
     * Returns the component (platform/plugin) update info
     */
    Kit.getComponentUpdateInfo = function (projectPath, kitId, installedComponentInfo, componentType) {
        if (componentType === void 0) { componentType = ProjectComponentType.Platform; }
        assert(componentType === ProjectComponentType.Platform || componentType === ProjectComponentType.Plugin);
        var componentUpdates = {};
        return kitHelper.getKitInfo(kitId).then(function (kitInfo) {
            var componentOverrides = (componentType === ProjectComponentType.Platform) ? kitInfo.platforms : kitInfo.plugins;
            if (!installedComponentInfo) {
                return Q.resolve({});
            }
            Object.keys(installedComponentInfo).forEach(function (key) {
                if (componentOverrides && componentOverrides[key] && componentOverrides[key].version && componentOverrides[key].version !== installedComponentInfo[key]) {
                    componentUpdates[key] = componentOverrides[key].version;
                }
            });
            return Q.resolve(componentUpdates);
        });
    };
    /**
     * Pretty prints the Cordova CLI version update info
     */
    Kit.printCordovaCliUpdateInfo = function (currentCli, newCli) {
        assert(currentCli);
        assert(newCli);
        if (currentCli === newCli) {
            return;
        }
        logger.logLine();
        logger.log(resources.getString("CommandKitListCordovaCliForKit", currentCli + " => " + newCli));
        logger.logLine();
    };
    Kit.projectComponentNeedsUpdate = function (installedComponentVersions, componentVersionUpdates) {
        if (componentVersionUpdates === void 0) { componentVersionUpdates = null; }
        return (installedComponentVersions && Object.keys(componentVersionUpdates || installedComponentVersions).length > 0);
    };
    /**
     * Pretty prints the platform and plugin update information
     */
    Kit.printProjectUpdateInfo = function (id, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates) {
        if (platformVersionUpdates === void 0) { platformVersionUpdates = null; }
        if (pluginVersionUpdates === void 0) { pluginVersionUpdates = null; }
        var indent = LoggerHelper.getDescriptionColumnIndent(Kit.getLongestPlatformPluginLength(installedPlatformVersions ? Object.keys(installedPlatformVersions) : null, installedPluginVersions ? Object.keys(installedPluginVersions) : null));
        var platformsRequireUpdate = Kit.projectComponentNeedsUpdate(installedPlatformVersions, platformVersionUpdates);
        var pluginsRequireUpdate = Kit.projectComponentNeedsUpdate(installedPluginVersions, pluginVersionUpdates);
        if (platformsRequireUpdate || pluginsRequireUpdate) {
            if (platformVersionUpdates || pluginVersionUpdates) {
                logger.log(resources.getString("CommandKitSelectKitPreview", id));
            }
            else {
                logger.log(resources.getString("CommandKitSelectCliPreview", id));
            }
            if (platformsRequireUpdate) {
                logger.logLine();
                logger.log(resources.getString("CommandKitListPlatformOverridesForKit"));
                Kit.printUpdateInfo(indent, installedPlatformVersions, platformVersionUpdates, ProjectComponentType.Platform);
            }
            if (pluginsRequireUpdate) {
                logger.logLine();
                logger.log(resources.getString("CommandKitListPluginOverridesForKit"));
                Kit.printUpdateInfo(indent, installedPluginVersions, pluginVersionUpdates, ProjectComponentType.Plugin);
            }
            logger.log(resources.getString("CommandKitSelectProjectUpdateWarning"));
        }
    };
    Kit.printCliProjectUpdateInfo = function (currentCli, newCli, installedPlatformVersions, installedPluginVersions) {
        Kit.printCordovaCliUpdateInfo(currentCli, newCli);
        Kit.printProjectUpdateInfo(newCli, installedPlatformVersions, installedPluginVersions);
    };
    Kit.printKitProjectUpdateInfo = function (currentCli, kitId, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates) {
        return kitHelper.getKitInfo(kitId).then(function (info) {
            Kit.printCordovaCliUpdateInfo(currentCli, info["cordova-cli"]);
            Kit.printProjectUpdateInfo(kitId, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates);
        });
    };
    Kit.printUpdateInfo = function (indent, installedComponentInfo, componentUpdateInfo, componentType) {
        if (componentUpdateInfo === void 0) { componentUpdateInfo = null; }
        if (componentType === void 0) { componentType = ProjectComponentType.Platform; }
        assert(installedComponentInfo);
        var suffix = componentType === ProjectComponentType.Platform ? resources.getString("CommandKitSelectKitPlatformVersion") : resources.getString("CommandKitSelectKitPluginVersion");
        if (componentUpdateInfo) {
            LoggerHelper.logNameDescriptionTable(Object.keys(componentUpdateInfo).map(function (componentName) {
                return {
                    name: componentName,
                    description: installedComponentInfo[componentName] + " => " + componentUpdateInfo[componentName]
                };
            }), LoggerHelper.DEFAULT_INDENT, indent);
        }
        else {
            LoggerHelper.logNameDescriptionTable(Object.keys(installedComponentInfo).map(function (componentName) {
                return {
                    name: componentName,
                    description: installedComponentInfo[componentName] + " => " + suffix
                };
            }), LoggerHelper.DEFAULT_INDENT, indent);
        }
        logger.logLine();
    };
    /**
     * Returns a map of top level plugin versions that were installed from NPM (as opposed to local file system or GIT)
     */
    Kit.filterUpdatablePluginVerions = function (pluginVersions, nonUpdatablePlugins) {
        if (nonUpdatablePlugins) {
            var updatablePlugins = {};
            Object.keys(pluginVersions).filter(function (pluginName) { return nonUpdatablePlugins.indexOf(pluginName) === -1; })
                .forEach(function (pluginName) { return updatablePlugins[pluginName] = pluginVersions[pluginName]; });
            return updatablePlugins;
        }
        else {
            return pluginVersions;
        }
    };
    /**
     * Prints the list of plugins that were skipped for auto-update
     */
    Kit.printListOfComponentsSkippedForUpdate = function (components) {
        if (components && components.length > 0) {
            logger.logLine();
            logger.log(resources.getString("CommandKitSelectNoUpdateListHeader"));
            logger.logLine();
            components.forEach(function (component) {
                logger.logWarning(LoggerHelper.repeat(" ", LoggerHelper.DEFAULT_INDENT) + component);
            });
        }
    };
    /**
     * Returns the CLI version that was used to create the project
     */
    Kit.getCliversion = function (projectInfo) {
        var deferred = Q.defer();
        if (projectInfo.cordovaCliVersion.length === 0) {
            CordovaWrapper.getGlobalCordovaVersion().then(function (globalCordovaVersion) {
                deferred.resolve(globalCordovaVersion);
            });
        }
        else {
            deferred.resolve(projectInfo.cordovaCliVersion);
        }
        return deferred.promise;
    };
    /**
     * Changes the current kit used for the project at {projectPath} to {kitId}
     */
    Kit.selectKit = function (projectPath, projectInfo, kitInfo, kitId) {
        var installedPlatformVersions;
        var installedPluginVersions;
        var currentCliVersion;
        var tacoJsonEditParams = {
            projectPath: projectPath,
            isKitProject: true,
            version: kitId
        };
        CordovaHelper.ensureCordovaVersionAcceptable(kitInfo["cordova-cli"]);
        // Query the installed platform/plugin versions, non-updatable plugin info (child plugins/plugins that were installed from GIT/local file system) and over-write taco.json with the new kit ID
        return Q.all([ProjectHelper.getInstalledPlatformVersions(projectPath), ProjectHelper.getInstalledPluginVersions(projectPath), ProjectHelper.getNonUpdatablePlugins(projectPath)])
            .spread(function (platformVersions, pluginVersions, nonUpdatablePlugins) {
            installedPlatformVersions = platformVersions;
            installedPluginVersions = Kit.filterUpdatablePluginVerions(pluginVersions, nonUpdatablePlugins);
            return Q.all([Kit.getComponentUpdateInfo(projectPath, kitId, installedPlatformVersions, ProjectComponentType.Platform), Kit.getComponentUpdateInfo(projectPath, kitId, installedPluginVersions, ProjectComponentType.Plugin)])
                .spread(function (platformVersionUpdates, pluginVersionUpdates) {
                return Kit.getCliversion(projectInfo)
                    .then(function (cliVersion) {
                    currentCliVersion = cliVersion;
                    return Kit.printKitProjectUpdateInfo(currentCliVersion, kitId, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates)
                        .then(function () {
                        var projectRequiresUpdate = Kit.projectComponentNeedsUpdate(installedPlatformVersions, platformVersionUpdates) || Kit.projectComponentNeedsUpdate(installedPluginVersions, pluginVersionUpdates);
                        if (projectRequiresUpdate) {
                            Kit.printListOfComponentsSkippedForUpdate(nonUpdatablePlugins);
                            return Kit.promptAndUpdateProject(tacoJsonEditParams, installedPlatformVersions, installedPluginVersions, platformVersionUpdates, pluginVersionUpdates);
                        }
                        else {
                            return kitHelper.editTacoJsonFile(tacoJsonEditParams);
                        }
                    });
                });
            });
        });
    };
    /**
     * Validates whether the version string passed is a valid Cordova version
     */
    Kit.validateCliVersion = function (version) {
        if (!semver.valid(version)) {
            return Q.reject(errorHelper.get(TacoErrorCodes.ErrorInvalidVersion, version, "cordova"));
        }
        CordovaHelper.ensureCordovaVersionAcceptable(version);
        return NpmHelper.view("cordova", ["versions"])
            .then(function (versions) {
            if (versions.indexOf(version) !== -1) {
                return version;
            }
            else {
                throw errorHelper.get(TacoErrorCodes.ErrorInvalidVersion, version, "cordova");
            }
        });
    };
    /**
     * Changes the current Cordova CLI used for the project at {projectPath} to {cli}
     */
    Kit.selectCli = function (projectPath, projectInfo, newCliVersion) {
        var tacoJsonEditParams = {
            projectPath: projectPath,
            isKitProject: false,
            version: newCliVersion
        };
        return Kit.validateCliVersion(newCliVersion)
            .then(function () {
            return Q.all([ProjectHelper.getInstalledPlatformVersions(projectPath), ProjectHelper.getInstalledPluginVersions(projectPath), ProjectHelper.getNonUpdatablePlugins(projectPath)])
                .spread(function (platformVersions, pluginVersions, nonUpdatablePlugins) {
                var pluginsToUpdate = Kit.filterUpdatablePluginVerions(pluginVersions, nonUpdatablePlugins);
                return Kit.getCliversion(projectInfo)
                    .then(function (currentCliVersion) {
                    Kit.printCliProjectUpdateInfo(currentCliVersion, newCliVersion, platformVersions, pluginsToUpdate);
                    var projectRequiresUpdate = ((platformVersions && Object.keys(platformVersions).length > 0) || (pluginVersions && Object.keys(pluginVersions).length > 0)) ? true : false;
                    if (projectRequiresUpdate) {
                        Kit.printListOfComponentsSkippedForUpdate(nonUpdatablePlugins);
                        return Kit.promptAndUpdateProject(tacoJsonEditParams, platformVersions, pluginsToUpdate);
                    }
                    else {
                        return kitHelper.editTacoJsonFile(tacoJsonEditParams);
                    }
                });
            });
        });
    };
    Kit.prototype.select = function () {
        var commandData = this.data;
        var kitId = commandData.options["kit"];
        var cli = commandData.options["cordova"];
        var projectInfo;
        var projectPath = ProjectHelper.getProjectRoot();
        logger.logLine();
        return ProjectHelper.getProjectInfo().then(function (info) {
            projectInfo = info;
            if (info.configXmlPath === "") {
                throw errorHelper.get(TacoErrorCodes.NotInCordovaProject);
            }
        })
            .then(function () {
            var usedkitId = projectInfo.tacoKitId;
            if (kitId) {
                if (usedkitId && usedkitId === kitId) {
                    throw errorHelper.get(TacoErrorCodes.CommandKitProjectUsesSameKit, kitId);
                }
                else {
                    return kitHelper.getKitInfo(kitId).then(function (kitInfo) {
                        return Kit.selectKit(projectPath, projectInfo, kitInfo, kitId);
                    });
                }
            }
            else if (cli) {
                var usedCli = projectInfo.cordovaCliVersion;
                if (!usedkitId && usedCli && usedCli === cli) {
                    throw errorHelper.get(TacoErrorCodes.CommandKitProjectUsesSameCordovaCli, cli);
                }
                else {
                    return Kit.selectCli(projectPath, projectInfo, cli);
                }
            }
            else {
                throw errorHelper.get(TacoErrorCodes.CommandKitCliOrKitShouldBeSpecified);
            }
        }).then(function () {
            logger.log(resources.getString("CommandKitSelectStatusSuccess"));
        }).then(function () { return Kit.generateTelemetryProperties(commandData, "select"); });
    };
    Kit.prototype.list = function () {
        var commandData = this.data;
        logger.logLine();
        var kitId = commandData.options["kit"];
        var jsonPath = commandData.options["json"];
        var result;
        if (typeof jsonPath !== "undefined") {
            result = Kit.writeMetadataJsonFile(commandData);
        }
        else {
            // If the user requested for info regarding a particular kit, print all the information regarding the kit  
            // Else print minimal information about all the kits
            result = (kitId ? Kit.printKit(kitId) : Kit.printAllKits());
        }
        return result.then(function () { return Kit.generateTelemetryProperties(commandData, "list"); });
    };
    Kit.prototype.parseArgs = function (args) {
        var parsedOptions = tacoUtility.ArgsHelper.parseArguments(Kit.KNOWN_OPTIONS, Kit.SHORT_HANDS, args, 0);
        // Raise errors for invalid command line parameter combinations
        if (parsedOptions.options.hasOwnProperty("json") && parsedOptions.options.hasOwnProperty("cordova")) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--json", "--cordova");
        }
        if (parsedOptions.options.hasOwnProperty("cordova") && parsedOptions.options.hasOwnProperty("kit")) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--cordova", "--kit");
        }
        if (parsedOptions.options.hasOwnProperty("json") && parsedOptions.options.hasOwnProperty("kit")) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--kit", "--json");
        }
        return parsedOptions;
    };
    /**
     * Mockable CLI for test purposes
     */
    Kit.yesOrNoHandler = null;
    Kit.KNOWN_OPTIONS = {
        kit: String,
        json: String,
        cordova: String
    };
    Kit.INDENT_WIDTH = 3; // indent string
    Kit.MAX_TEXT_WIDTH = 40;
    Kit.DEFAULT_METADATA_FILENAME = "KitMetadata.json";
    Kit.SHORT_HANDS = {};
    return Kit;
}(commands.TacoCommandBase));
module.exports = Kit;

//# sourceMappingURL=kit.js.map
