// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/tacoKits.d.ts" />
/// <reference path="../../typings/node.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Q = require("q");
var KitHelper = require("./utils/kitHelper");
var resources = require("../resources/resourceManager");
var cordovaComponentCommand = require("./utils/cordovaComponentCommand");
var Settings = require("./utils/settings");
var tacoUtility = require("taco-utils");
var CordovaHelper = tacoUtility.CordovaHelper;
var CordovaWrapper = tacoUtility.CordovaWrapper;
var CordovaComponentCommand = cordovaComponentCommand.CordovaComponentCommand;
var Logger = tacoUtility.Logger;
var LoggerHelper = tacoUtility.LoggerHelper;
/**
 * Platform
 *
 * Handles "taco platform"
 */
var Platform = (function (_super) {
    __extends(Platform, _super);
    function Platform() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = "platform";
        this.subcommands = [
            {
                // taco plaform add <platform>
                name: "add",
                run: function () { return _this.add(); }
            },
            {
                // taco plaform list
                name: "list",
                run: function () { return _this.list(); }
            },
            {
                // taco plaform remote/update/check <platform>
                name: "fallback",
                run: function () { return _this.passthrough(); },
                canHandleArgs: function () { return true; }
            },
        ];
    }
    Object.defineProperty(Platform.prototype, "knownOptions", {
        get: function () {
            return Platform.KNOWN_OPTIONS;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Platform.prototype, "knownSubCommands", {
        get: function () {
            return Platform.KNOWN_SUBCOMMANDS;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Platform.prototype, "shortFlags", {
        get: function () {
            return Platform.SHORT_HANDS;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Platform.prototype, "knownTargetsSubCommands", {
        get: function () {
            return Platform.KNOWN_TARGETS_SUBCOMMANDS;
        },
        enumerable: true,
        configurable: true
    });
    Platform.prototype.getCommandOptions = function (commandData) {
        return {
            usegit: commandData.options["usegit"],
            link: commandData.options["link"],
            save: commandData.options["save"],
        };
    };
    Platform.prototype.runCordovaCommand = function (targets) {
        var commandData = this.data;
        return CordovaWrapper.platform(commandData.subCommand, commandData, targets, commandData.commandOptions);
    };
    Platform.prototype.getConfigXmlVersionSpec = function (targetName, projectInfo) {
        return CordovaHelper.getEngineVersionSpec(targetName, projectInfo);
    };
    Platform.prototype.editVersionOverrideInfo = function (platformInfos, projectInfo) {
        var infos = platformInfos.map(function (info) { return { name: info.name, spec: info.spec }; });
        return CordovaHelper.editEngineVersionSpecs(infos, projectInfo);
    };
    Platform.prototype.getKitOverride = function (platformName, kitId) {
        return KitHelper.getPlatformOverridesForKit(kitId)
            .then(function (kitOverrides) {
            var version = "";
            var src = "";
            if (kitOverrides && kitOverrides[platformName]) {
                version = kitOverrides[platformName].version;
                src = kitOverrides[platformName].src;
            }
            return CordovaComponentCommand.makeCordovaComponentInfo(platformName, version, src);
        });
    };
    /**
     * Prints the platform addition/removal operation progress message
     */
    Platform.prototype.printInProgressMessage = function (platforms) {
        var commandData = this.data;
        switch (commandData.subCommand) {
            case "add":
                {
                    Logger.log(resources.getString("CommandPlatformStatusAdding", platforms));
                }
                break;
            case "remove":
                {
                    Logger.log(resources.getString("CommandPlatformStatusRemoving", platforms));
                }
                break;
            case "update": {
                Logger.log(resources.getString("CommandPlatformStatusUpdating", platforms));
                break;
            }
        }
    };
    /**
     * Prints the platform addition/removal operation success message
     */
    Platform.prototype.printSuccessMessage = function (platforms) {
        var commandData = this.data;
        switch (commandData.subCommand) {
            case "add": {
                Logger.log(resources.getString("CommandPlatformStatusAdded", platforms));
                // Print the onboarding experience
                Logger.log(resources.getString("OnboardingExperienceTitle"));
                LoggerHelper.logList(["HowToUseCommandInstallReqsPlugin",
                    "HowToUseCommandAddPlugin",
                    "HowToUseCommandSetupRemote",
                    "HowToUseCommandBuildPlatform",
                    "HowToUseCommandEmulatePlatform",
                    "HowToUseCommandRunPlatform"].map(function (msg) { return resources.getString(msg); }));
                ["",
                    "HowToUseCommandHelp",
                    "HowToUseCommandDocs"].forEach(function (msg) { return Logger.log(resources.getString(msg)); });
                break;
            }
            case "remove":
                Logger.log(resources.getString("CommandPlatformStatusRemoved", platforms));
                break;
            case "update":
                Logger.log(resources.getString("CommandPlatformStatusUpdated", platforms));
                break;
        }
    };
    Platform.prototype.list = function () {
        // platform list should include remotely configured platforms as well
        return Q.all([this.passthrough(), Settings.loadSettingsOrReturnEmpty()])
            .spread(function (telemetryProperties, settings) {
            var remotePlatforms = Object.keys(settings.remotePlatforms || {});
            Logger.log(resources.getString("PlatformListRemotePlatforms", remotePlatforms.join(",")));
            return telemetryProperties;
        });
    };
    Platform.KNOWN_OPTIONS = {
        usegit: String,
        link: Boolean,
        save: Boolean,
    };
    Platform.SHORT_HANDS = {};
    Platform.KNOWN_SUBCOMMANDS = ["add", "remove", "list", "update", "check"];
    // list of subcommands which require a target (for e.g. a platform name or plugin id)
    Platform.KNOWN_TARGETS_SUBCOMMANDS = ["add", "remove", "update"];
    return Platform;
}(CordovaComponentCommand));
module.exports = Platform;

//# sourceMappingURL=platform.js.map
