// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/nopt.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var assert = require("assert");
var path = require("path");
var Q = require("q");
var buildTelemetryHelper = require("./utils/buildTelemetryHelper");
var CleanHelperModule = require("./utils/cleanHelper");
var errorHelper = require("./tacoErrorHelper");
var PlatformHelper = require("./utils/platformHelper");
var RemoteBuildClientHelper = require("./remoteBuild/remoteBuildClientHelper");
var RemoteBuildSettings = require("./remoteBuild/buildSettings");
var resources = require("../resources/resourceManager");
var Settings = require("./utils/settings");
var TacoErrorCodes = require("./tacoErrorCodes");
var tacoUtility = require("taco-utils");
var CleanHelper = CleanHelperModule.CleanHelper;
var commands = tacoUtility.Commands;
var CordovaWrapper = tacoUtility.CordovaWrapper;
var logger = tacoUtility.Logger;
/**
 * Run
 *
 * handles "taco run"
 */
var Run = (function (_super) {
    __extends(Run, _super);
    function Run() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = "run";
        this.subcommands = [
            {
                // --list = targets
                name: "targets",
                run: function () { return _this.targets(); },
                canHandleArgs: function () { return !!_this.data.options["list"]; }
            },
            {
                // Remote Run
                name: "remote",
                run: function () { return _this.remote(); },
                canHandleArgs: function () { return !!_this.data.options["remote"]; }
            },
            {
                // Local Run
                name: "local",
                run: function () { return _this.local(); },
                canHandleArgs: function () { return !!_this.data.options["local"]; }
            },
            {
                // Fallback
                name: "fallback",
                run: function () { return _this.fallback(); },
                canHandleArgs: function () { return true; }
            }
        ];
    }
    Run.generateTelemetryProperties = function (telemetryProperties, commandData) {
        return buildTelemetryHelper.addCommandLineBasedPropertiesForBuildAndRun(telemetryProperties, Run.KNOWN_OPTIONS, commandData);
    };
    Run.prototype.targets = function () {
        return CordovaWrapper.targets(this.data);
    };
    Run.prototype.remote = function () {
        var commandData = this.data;
        var telemetryProperties = {};
        return Q.all([PlatformHelper.determinePlatform(commandData), Settings.loadSettingsOrReturnEmpty()])
            .spread(function (platforms, settings) {
            buildTelemetryHelper.storePlatforms(telemetryProperties, "actuallyBuilt", platforms, settings);
            return Run.cleanPlatformsIfNecessary(commandData, platforms).then(function () {
                return Q.all(platforms.map(function (platform) {
                    assert(platform.location === PlatformHelper.BuildLocationType.Remote);
                    return Run.runRemotePlatform(platform.platform, commandData, telemetryProperties);
                }));
            });
        }).then(function () { return Run.generateTelemetryProperties(telemetryProperties, commandData); });
    };
    Run.runRemotePlatform = function (platform, commandData, telemetryProperties) {
        return Q.all([Settings.loadSettings(), CordovaWrapper.getCordovaVersion()]).spread(function (settings, cordovaVersion) {
            var configuration = commandData.options["release"] ? "release" : "debug";
            var buildTarget = commandData.options["target"] || (commandData.options["device"] ? "device" : "");
            var language = settings.language || "en";
            var remoteConfig = settings.remotePlatforms && settings.remotePlatforms[platform];
            if (!remoteConfig) {
                throw errorHelper.get(TacoErrorCodes.CommandRemotePlatformNotKnown, platform);
            }
            // DeviceSync/LiveReload not compatible with remote
            var deviceSync = commandData.options["livereload"] || commandData.options["devicesync"];
            if (deviceSync) {
                throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--livereload/--devicesync", "--remote");
            }
            var buildOptions = commandData.remain.filter(function (opt) { return opt.indexOf("--") === 0; });
            var buildInfoPath = path.resolve(".", "remote", platform, configuration, "buildInfo.json");
            var buildInfoPromise;
            var buildSettings = new RemoteBuildSettings({
                projectSourceDir: path.resolve("."),
                buildServerInfo: remoteConfig,
                buildCommand: "build",
                platform: platform,
                configuration: configuration,
                buildTarget: buildTarget,
                language: language,
                cordovaVersion: cordovaVersion,
                options: buildOptions
            });
            // Find the build that we are supposed to run
            if (commandData.options["nobuild"]) {
                buildInfoPromise = RemoteBuildClientHelper.checkForBuildOnServer(buildSettings, buildInfoPath).then(function (buildInfo) {
                    if (!buildInfo) {
                        // No info for the remote build: User must build first
                        var buildCommandToRun = "taco build" + ([commandData.options["remote"] ? " --remote" : ""].concat(commandData.remain).join(" "));
                        throw errorHelper.get(TacoErrorCodes.NoRemoteBuildIdFound, buildCommandToRun);
                    }
                    else {
                        return buildInfo;
                    }
                });
            }
            else {
                // Always do a rebuild, but incrementally if possible.
                buildInfoPromise = RemoteBuildClientHelper.build(buildSettings, telemetryProperties);
            }
            // Default to a simulator/emulator build unless explicitly asked otherwise
            // This makes sure that our defaults match Cordova's, as well as being consistent between our own build and run.
            var runPromise;
            if (commandData.options["device"]) {
                runPromise = buildInfoPromise.then(function (buildInfo) {
                    return RemoteBuildClientHelper.run(buildInfo, remoteConfig);
                }).then(function (buildInfo) {
                    logger.log(resources.getString("CommandRunRemoteDeviceSuccess"));
                    return buildInfo;
                });
            }
            else {
                runPromise = buildInfoPromise.then(function (buildInfo) {
                    return RemoteBuildClientHelper.emulate(buildInfo, remoteConfig, buildTarget);
                }).then(function (buildInfo) {
                    logger.log(resources.getString("CommandRunRemoteEmulatorSuccess"));
                    return buildInfo;
                });
            }
            return runPromise.then(function (buildInfo) {
                if (commandData.options["debuginfo"]) {
                    // enable debugging and report connection information
                    return RemoteBuildClientHelper.debug(buildInfo, remoteConfig)
                        .then(function (debugBuildInfo) {
                        if (debugBuildInfo["webDebugProxyPort"]) {
                            logger.log(JSON.stringify({ webDebugProxyPort: debugBuildInfo["webDebugProxyPort"] }));
                        }
                        return debugBuildInfo;
                    });
                }
                else {
                    return Q(buildInfo);
                }
            });
        });
    };
    Run.prototype.runLocal = function (localPlatforms) {
        var _this = this;
        var self = this;
        return Run.cleanPlatformsIfNecessary(this.data).then(function () {
            if (_this.data.options["livereload"] || _this.data.options["devicesync"]) {
                // intentionally delay-requiring it since liveReload fetches whole bunch of stuff
                var liveReload = require("./liveReload");
                return liveReload.hookLiveReload(_this.data.options, localPlatforms)
                    .then(function () { return CordovaWrapper.run(self.data, localPlatforms); });
            }
            return CordovaWrapper.run(_this.data, localPlatforms);
        });
    };
    Run.prototype.local = function () {
        var commandData = this.data;
        return this.runLocal()
            .then(function () { return Run.generateTelemetryProperties({}, commandData); });
    };
    Run.cleanPlatformsIfNecessary = function (commandData, platforms) {
        if (commandData.options["clean"]) {
            var determinePlatformsPromise;
            if (platforms) {
                determinePlatformsPromise = Q(platforms);
            }
            else {
                determinePlatformsPromise = PlatformHelper.determinePlatform(commandData);
            }
            return determinePlatformsPromise.then(function (plats) {
                CleanHelper.cleanPlatforms(plats, commandData);
            });
        }
        return Q({});
    };
    Run.prototype.fallback = function () {
        var commandData = this.data;
        var telemetryProperties = {};
        var self = this;
        return Q.all([PlatformHelper.determinePlatform(commandData), Settings.loadSettingsOrReturnEmpty()])
            .spread(function (platforms, settings) {
            buildTelemetryHelper.storePlatforms(telemetryProperties, "actuallyBuilt", platforms, settings);
            return Run.cleanPlatformsIfNecessary(commandData, platforms).then(function () {
                return PlatformHelper.operateOnPlatforms(platforms, function (localPlatforms) { return self.runLocal(localPlatforms); }, function (remotePlatform) { return Run.runRemotePlatform(remotePlatform, commandData, telemetryProperties); });
            });
        }).then(function () { return Run.generateTelemetryProperties(telemetryProperties, commandData); });
    };
    Run.prototype.parseArgs = function (args) {
        var parsedOptions = tacoUtility.ArgsHelper.parseArguments(Run.KNOWN_OPTIONS, Run.SHORT_HANDS, args, 0);
        // Raise errors for invalid command line parameters
        if (parsedOptions.options["remote"] && parsedOptions.options["local"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--remote", "--local");
        }
        if (parsedOptions.options["device"] && parsedOptions.options["emulator"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--device", "--emulator");
        }
        if (parsedOptions.options["debug"] && parsedOptions.options["release"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--debug", "--release");
        }
        if (parsedOptions.options["livereload"] && parsedOptions.options["remote"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--livereload", "--remote");
        }
        if (parsedOptions.options["devicesync"] && parsedOptions.options["remote"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--devicesync", "--remote");
        }
        if (parsedOptions.options["devicesync"] && parsedOptions.options["livereload"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--devicesync", "--livereload");
        }
        if (parsedOptions.options["nobuild"] && parsedOptions.options["clean"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--nobuild", "--clean");
        }
        return parsedOptions;
    };
    Run.KNOWN_OPTIONS = {
        local: Boolean,
        remote: Boolean,
        clean: Boolean,
        debuginfo: Boolean,
        nobuild: Boolean,
        list: Boolean,
        device: Boolean,
        emulator: Boolean,
        target: String,
        livereload: Boolean,
        devicesync: Boolean,
        // Are these only for when we build as part of running?
        debug: Boolean,
        release: Boolean
    };
    Run.SHORT_HANDS = {};
    return Run;
}(commands.TacoCommandBase));
module.exports = Run;

//# sourceMappingURL=run.js.map
