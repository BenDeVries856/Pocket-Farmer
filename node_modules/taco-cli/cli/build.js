// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
/// <reference path="../../typings/tacoUtils.d.ts" />
/// <reference path="../../typings/node.d.ts" />
/// <reference path="../../typings/nopt.d.ts" />
/// <reference path="../../typings/cordovaExtensions.d.ts" />
/// <reference path="../../typings/rimraf.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require("path");
var Q = require("q");
var buildTelemetryHelper = require("./utils/buildTelemetryHelper");
var CleanHelperModule = require("./utils/cleanHelper");
var errorHelper = require("./tacoErrorHelper");
var PlatformHelper = require("./utils/platformHelper");
var RemoteBuildClientHelper = require("./remoteBuild/remoteBuildClientHelper");
var RemoteBuildSettings = require("./remoteBuild/buildSettings");
var resources = require("../resources/resourceManager");
var Settings = require("./utils/settings");
var TacoErrorCodes = require("./tacoErrorCodes");
var tacoUtility = require("taco-utils");
var CleanHelper = CleanHelperModule.CleanHelper;
var commands = tacoUtility.Commands;
var CordovaWrapper = tacoUtility.CordovaWrapper;
var logger = tacoUtility.Logger;
var ProjectHelper = tacoUtility.ProjectHelper;
/**
 * Build
 *
 * handles "taco build"
 */
var Build = (function (_super) {
    __extends(Build, _super);
    function Build() {
        _super.apply(this, arguments);
        this.name = "build";
    }
    Build.generateTelemetryProperties = function (telemetryProperties, commandData) {
        return buildTelemetryHelper.addCommandLineBasedPropertiesForBuildAndRun(telemetryProperties, Build.KNOWN_OPTIONS, commandData);
    };
    Build.buildRemotePlatform = function (platform, commandData, telemetryProperties) {
        var configuration = commandData.options["release"] ? "release" : "debug";
        var buildTarget = commandData.options["target"] || (commandData.options["device"] ? "device" : commandData.options["emulator"] ? "emulator" : "");
        return Q.all([Settings.loadSettings(), CordovaWrapper.getCordovaVersion()]).spread(function (settings, cordovaVersion) {
            var language = settings.language || "en";
            var remoteConfig = settings.remotePlatforms && settings.remotePlatforms[platform];
            if (!remoteConfig) {
                throw errorHelper.get(TacoErrorCodes.CommandRemotePlatformNotKnown, platform);
            }
            var buildSettings = new RemoteBuildSettings({
                projectSourceDir: path.resolve("."),
                buildServerInfo: remoteConfig,
                buildCommand: "build",
                platform: platform,
                configuration: configuration,
                buildTarget: buildTarget,
                language: language,
                cordovaVersion: cordovaVersion
            });
            return Build.remoteBuild.build(buildSettings, telemetryProperties);
        });
    };
    Build.prototype.runCommand = function () {
        if (ProjectHelper.isTypeScriptProject()) {
            logger.log(resources.getString("CommandCreateInstallGulp"));
        }
        var commandData = this.data;
        var telemetryProperties = {};
        return Q.all([PlatformHelper.determinePlatform(commandData), Settings.loadSettingsOrReturnEmpty()])
            .spread(function (platforms, settings) {
            buildTelemetryHelper.storePlatforms(telemetryProperties, "actuallyBuilt", platforms, settings);
            var cleanPromise = Q({});
            if (commandData.options["clean"]) {
                cleanPromise = CleanHelper.cleanPlatforms(platforms, commandData);
            }
            return cleanPromise.then(function () {
                return PlatformHelper.operateOnPlatforms(platforms, function (localPlatforms) { return CordovaWrapper.build(commandData, localPlatforms); }, function (remotePlatform) { return Build.buildRemotePlatform(remotePlatform, commandData, telemetryProperties); });
            });
        }).then(function () { return Build.generateTelemetryProperties(telemetryProperties, commandData); });
    };
    Build.prototype.parseArgs = function (args) {
        var parsedOptions = tacoUtility.ArgsHelper.parseArguments(Build.KNOWN_OPTIONS, Build.SHORT_HANDS, args, 0);
        // Raise errors for invalid command line parameters
        if (parsedOptions.options["remote"] && parsedOptions.options["local"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--remote", "--local");
        }
        if (parsedOptions.options["device"] && parsedOptions.options["emulator"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--device", "--emulator");
        }
        if (parsedOptions.options["debug"] && parsedOptions.options["release"]) {
            throw errorHelper.get(TacoErrorCodes.ErrorIncompatibleOptions, "--debug", "--release");
        }
        return parsedOptions;
    };
    /*
     * Exposed for testing purposes: when we talk to a mocked server we don't want 5s delays between pings
     */
    Build.remoteBuild = RemoteBuildClientHelper;
    Build.KNOWN_OPTIONS = {
        local: Boolean,
        remote: Boolean,
        clean: Boolean,
        debug: Boolean,
        release: Boolean,
        device: Boolean,
        emulator: Boolean,
        target: String
    };
    Build.SHORT_HANDS = {};
    return Build;
}(commands.TacoCommandBase));
module.exports = Build;

//# sourceMappingURL=build.js.map
